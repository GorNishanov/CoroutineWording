
%%
%% Declarations
%%
\setcounter{chapter}{6}
\rSec0[dcl.dcl]{Declarations}

%%
%% Auto specifier
%%
\setcounter{section}{1}
\setcounter{subsection}{5}
\setcounter{subsubsection}{3}
\rSec3[dcl.spec.auto]{\tcode{auto} specifier}

Add underlined text to paragraph two.

\begin{quote}
\setcounter{Paras}{1}
\pnum
The placeholder type can appear with a function declarator in the
\grammarterm{decl-specifier-seq}, \grammarterm{type-specifier-seq},
\grammarterm{conversion-function-id}, or \grammarterm{trailing-return-type},
in any context where such a declarator is valid. If the function declarator
includes a \grammarterm{trailing-return-type}~(\cxxref{dcl.fct}), that specifies
the declared return type of the function. If the declared return type of the
function contains a placeholder type, the return type of the function is
deduced from \tcode{return} statements in the body of the function \added{and/or \tcode{yield} statements}, if any.
\end{quote}

add paragraphs 16 and 17.

\begin{quote}
\setcounter{Paras}{15}
\pnum
If a resumable function with a declared return type that contains a placeholder type has multiple \tcode{yield} statements, the return type is deduced for each
\tcode{yield} statement. If the type deduced is not the same in each
deduction, the program is ill-formed.

\pnum
If a resumable function with a declared return type that contains a placeholder type, then the return type of the resumable function is deduced as follows:

\begin{itemize}
\item If a \tcode{yield} statement and either an \tcode{await} expression or a \tcode{for await} statement are present, then
the return type is \tcode{std::experimental::async_stream<T>}, where T is deduced from the \tcode{yield} statements.

\item Otherwise, if an \tcode{await} expression or a \tcode{for await} statement are present in a function, then
the return type is \tcode{std::experimental::task<T>} where type T is deduced from 
\tcode{return} statements.

\item Otherwise, if a \tcode{yield} statement is present in a function, then return type is
\tcode{std::experimental::generator<T>},
where \tcode{T} is deduced from the \tcode{yield} statements.

\end{itemize}
\enterexample
\begin{codeblock}
// deduces to std::experimental::generator<char>
auto f() { for(auto ch: "Hello") yield ch; }

// deduces to std::experimental::async_stream<int>
auto ticks() {
  for(int tick = 0;; ++tick) {
    yield tick;
    await sleep_for(1ms);
  }
}

// deduces to std::experimental::task<void>
auto f() {  await g(); }

\end{codeblock}
\exitexample
\end{quote}
\ednote{Class templates \tcode{std::experimental::generator}, 
\tcode{std::experimental::task} and 
\tcode{std::experimental::async_stream} are not specified in this proposal
and will be developed as more experience with resumable function is accumulated.}
