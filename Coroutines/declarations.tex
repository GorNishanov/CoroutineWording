
%%
%% Declarations
%%
\setcounter{chapter}{6}
\rSec0[dcl.dcl]{Declarations}

%%
%% constexpr specifier
%%
\setcounter{section}{1}
\setcounter{subsection}{4}
\rSec2[dcl.constexpr]{The \tcode{constexpr} specifier}%

Add the underlined text as the last item in the list in paragraph 3. Note that
the preceding (unmodified) items in the \Cpp Standard are elided in this
document.

\begin{quote}
  \setcounter{Paras}{2}
\pnum
\indextext{specifier!\idxcode{constexpr}!function}
\indextext{constexpr function}
The definition of a \tcode{constexpr} function shall satisfy the following
constraints:

\begin{itemize}
  \item \ldots
  \item \ldots
  \item \ldots
  \item \ldots
  \item \added{it shall not be a coroutine (\ref{dcl.fct.def.coroutine})};
\end{itemize}
\end{quote}

%\ednote{
%  Though in the current proposal we do not allow constexpr coroutines,
%  we envision that generator style coroutines with yield statements
%  can be constexpr with some restrictions.
%  The following example is a part of this editorial note and should not be included in the \Cpp standard.}
%
%\enterexample \tcode{constexpr} \textit{pack generators} looks promising and may be explored in the future in a separate proposal. The teaser snippet:
%  
%\begin{codeblock} 
%  constexpr auto int_range(int from, int to_excl) {
%    for (int k = from; k<to_excl; ++k) {
%      yield k;  // Produce a new value.
%    }
%  }
%      
%  int digits[] = { int_range(0, 9)... };
%\end{codeblock} 
%\exitexample

%%
%% Auto specifier
%%
\setcounter{section}{1}
\setcounter{subsection}{6}
\setcounter{subsubsection}{3}
\rSec3[dcl.spec.auto]{\tcode{auto} specifier}

Add the underlined text to paragraph 2.

\begin{quote}
\setcounter{Paras}{1}
\pnum
The placeholder type can appear with a function declarator in the
\grammarterm{decl-specifier-seq}, \grammarterm{type-specifier-seq},
\grammarterm{conversion-function-id}, or \grammarterm{trailing-return-type},
in any context where such a declarator is valid. If the function declarator
includes a \grammarterm{trailing-return-type}~(\cxxref{dcl.fct}), that specifies
the declared return type of the function. If the declared return type of the
function contains a placeholder type, the return type of the function is
deduced from \tcode{return},\added{ \tcode{coreturn-keyword}, and \tcode{yield_kw}} statements in the body of the function, if any.
\end{quote}

Add the underlined text to paragraph 9.

\begin{quote}
\setcounter{Paras}{8}
\pnum
If a function with a declared return type that contains a placeholder type has
multiple \tcode{return}\added{, \tcode{coreturn-keyword}, and \tcode{yield_kw}} statements, the return type is deduced for each
\tcode{return}\added{, \linebreak
\tcode{coreturn-keyword}, and \tcode{yield_kw}} statement. If the type deduced is not the same in each
deduction, the program is ill-formed.
\end{quote}

Add paragraphs 16 through 18.

\begin{quote}
\setcounter{Paras}{15}

%integrate with paragraph 9
%\ednote{Incomplete edit. See if the next paragraph can be integrated with paragraph 9.}
%
%\pnum
%If a coroutine has a declared return type that contains a placeholder type has multiple \tcode{yield_kw}/\tcode{coreturn} statements, the return type is deduced for each
%\tcode{yield_kw}/\tcode{coreturn} statement. If the type deduced is not the same in each
%deduction, the program is ill-formed.

\pnum
If a coroutine has a declared return type that contains a placeholder type, then the return type of the coroutine is deduced as follows:

\begin{itemize}
\item If a \tcode{yield_kw} statement and an \grammarterm{await-expression} are present, then
the return type is \tcode{std::experimental::async_stream<T>}, where \tcode{T} is deduced from the \tcode{yield_kw} statements as if a \tcode{yield_kw} statement were a \tcode{return} statement in a function with declared type \tcode{auto} without a \grammarterm{trailing-return-type}.

%NOTE Jens text

\item Otherwise, if an \grammarterm{await-expression} is present in a function, then
the return type is\linebreak \tcode{std::experimental::task<T>} where type \tcode{T} is deduced from 
\tcode{coreturn-keyword} statements as if a \tcode{coreturn-keyword} statement were a \tcode{return} statement in a function with declared type \tcode{auto} without a \grammarterm{trailing-return-type}.

%NOTE: as if 

\item Otherwise, if a \tcode{yield_kw} statement is present in a function, then the return type is \linebreak
\tcode{std::experimental::generator<T>},
where \tcode{T} is deduced from the \tcode{yield_kw} statements  as if a \tcode{yield_kw} statement were a \tcode{return} statement in a function with declared type \tcode{auto} without a \grammarterm{trailing-return-type}.

\end{itemize}
\enterexample
\begin{codeblock}
// deduces to std::experimental::generator<char>
auto f() { for(auto ch: "Hello") yield_kw ch; }

// deduces to std::experimental::async_stream<int>
auto ticks() {
  for(int tick = 0;; ++tick) {
    yield_kw tick;
    await_kw sleep_for(1ms);
  }
}

future<void> g();

// deduces to std::experimental::task<void>
auto f2() {  await_kw g(); }

\end{codeblock}
\exitexample

\pnum
The templates  \tcode{std::experimental::generator}, 
\tcode{std::experimental::task}, and \linebreak
\tcode{std::experimental::async_stream} are not predefined;
if the appropriate headers are not included prior to a use --- even an implicit use in which the type is not
named~(\ref{dcl.spec.auto}) --- the program is ill-formed.
\end{quote}
%\ednote{Class templates \tcode{std::experimental::generator}, 
%\tcode{std::experimental::task}, and \linebreak
%\tcode{std::experimental::async_stream} are not specified in this proposal
%and will be developed as more experience with coroutines is accumulated.}
