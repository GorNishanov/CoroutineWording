
%%
%% Declarators
%%
\rSec0[dcl.decl]{Declarators}

\setcounter{section}{3}
\setcounter{subsection}{4}
\rSec2[dcl.fct]{Functions}%

%NOTES: Fix
Add paragraph 16.

\begin{quote}
\setcounter{Paras}{15}
\pnum
If the \grammarterm{parameter-declaration-clause} terminates with an ellipsis that is not part of \grammarterm{abstract-declarator}, a function shall not be coroutine (\ref{dcl.fct.def.coroutine}).
\end{quote}

\setcounter{section}{3}
\rSec1[dcl.fct.def]{Function definitions}

\setcounter{subsection}{3}
\rSec2[dcl.fct.def.coroutine]{Coroutines}

Add this section to \ref{dcl.fct.def}.

%\rSec3[coroutine.definitions]{Definitions}
\begin{quote}
\pnum
A function is a \defn{coroutine} if it contains
one or more suspend-resume points. 

\pnum
A \defn{suspend-resume point} is introduced by a potenitally-evaluated \tcode{coawait} operator (\ref{expr.await}) expression and a \tcode{coyield} statement (\ref{stmt.yield}).
% implicit NOTE: including implicit
%, or a \tcode{cofor} statement (\ref{stmt.for.await}).
Every coroutine
also has an implicit initial and final suspend-resume point as described later in this section. 

\pnum
\enternote
From the perspective of the caller, a coroutine is just a function with that particular signature. The fact that a function is implemented as a coroutine is unobservable by the caller. 
\exitnote

\pnum
A coroutine needs a set of related types and functions
to complete the definition of its semantics.
These types and functions are provided as a set of member types or typedefs
and member functions in the specializations of struct template
\tcode{coroutine_traits} (\ref{coroutine.traits}). 

\pnum
For a coroutine \textit{f}, let \textit{R} be the return type and $P_1$, $P_2$, ..., $P_n$
be the types of the parameters. If \textit{f} is a non-static member function, then $P_1$ denotes the type of the implicit object parameter. 
%Coroutine traits for function \tcode{f} is a specialization of
%struct template \tcode{std::experimental::coroutine_traits<R,P1,...,PN>}.
Let \textit{F} be the \grammarterm{function-body}
%\footnote{
%Due to requirement of having suspend-resume points,
%\grammarterm{function-body} is either a
%\grammarterm{compound-statement} or 
%\grammarterm{function-try-block}.
%}
of \textit{f}, \textit{T} be a type \tcode{std::experimental::coroutine_traits<$R$,$P_1$,...,$P_N$>}, and \textit{P} be the type denoted by \textit{T::}\tcode{promise_type}. 
%If \textit{T}\tcode{::promise_type} does not refer to a type the program is ill-formed. Type \textit{P} is the \term{promise type} of the coroutine.
Then, the coroutine behaves as if its body were:
\begin{codeblock}
  {
     @\textit{P p}@;
     if (@\textit{p}@.initial_suspend()) {
       @\textit{<suspend-resume point>}@ // initial suspend point
     }
     @\textit{F'}@
     if (@\textit{p}@.final_suspend()) {
       @\textit{<suspend-resume point>}@ // final suspend point
     }
  }
\end{codeblock}
where local variable \textit{p} is 
defined for
exposition only and
\textit{F'} is \textit{F}
if \textit{P} does not define a \tcode{set_exception} member function, 
and 
\begin{codeblock}
  try {@\textit{F}@} catch(...) {@\textit{p}@.set_exception(std::current_exception());}
\end{codeblock}

otherwise. An object denoted as \textit{p} is the \defn{promise object} of
the coroutine \textit{f} and its type is a \defn{promise type}
of the coroutine.
An execution of a coroutine is suspended when it reaches a suspend-resume point.

\pnum 
A \defn{suspension} of a coroutine returns control to the current
caller of the coroutine. For the first return of control from the coroutine, the return value is obtained by invoking the member function 
\tcode{get_return_object} (\ref{coroutine.promise})
of the promise object.

%\enternote
%For subsequent suspends, if any, the coroutine
%is invoked via resumption member functions of 
%%NOTE massage
%\tcode{std::experimental::coroutine_handle} (\ref{coroutine.handle}) and no return value is expected.
%\exitnote

\pnum
A suspended coroutine can be resumed
to continue execution by invoking
a resumption member functions (\ref{coroutine.handle.resumption}) of an object of \tcode{coroutine_handle<$P$>} type
associated with this instance of a coroutine, where type $P$
is a promise type of the coroutine. 

\pnum
A coroutine may need to allocate
memory to store objects with automatic storage duration
local to the coroutine. If so, it must
use the allocator object obtained as described in 
Table~\ref{tab:coroutine.traits.requirements} in clause \ref{coroutine.traits}.

\pnum
A \defn{coroutine state} consists of 
storage for objects with automatic storage duration
that are live at the current point of execution or suspension of 
a coroutine.
The \term{coroutine state} is destroyed when
the control flows off the end of the function or
the \tcode{destroy} member function (\ref{coroutine.handle.resumption}) of an object of \tcode{std::experimental::coroutine_handle<\textit{P}}> associated with that coroutine.

%introduce metavariable instead of talking about
%coroutine_handle<>

%\pnum
%An invocation of a coroutine may incur a move operation for the parameters that may be accessed in the \grammarterm{function-body}
%of coroutine after a resume. 
%These copies are defined in the same scope as a \term{promise object}. 
%References to those parameters in the \grammarterm{function-body}
%of the coroutine are replaced with 
%references to their copies.

%If a parameter copy/move is required, class object moves are performed according to the rules described in \cxxref{class.copy}.
%%NOTE: whatever 
%
%struct S {
%  int a;
%  int b;
%};
%
%new (p) S{move(a), move(b)};

%NOTE: massage
\pnum
The coroutine state is copy-initialized with the parameter values considered as xvalues. 
This copy may be elided.


%NOTE: say something that we need to check
%Will be moved to coroutine state and can elide the move.
%syntactic constraint will be checked.

%NOTE: eventual-return type not defined anywhere

\pnum
If the coroutine state initialization, a call to \tcode{get_return_object}, or a promise object construction throws
an exception, 
%objects with automatic storage duration (\cxxref{basic.stc.auto}) that have been
%constructed are destroyed in the reverse order of their construction, 
any memory dynamically allocated 
for the coroutine state is freed.
%and the search for a handler starts in the scope of the calling function. 

%\pnum A coroutine shall not have an ellipsis parameter specification. 


%\begin{codeblock}
%R f(T1 a, T2 b) {
%  // specialize coroutine_traits to discover customization points
%  using _Traits = std::experimental::coroutine_traits<R,T1,T2>;
%  <allocate memory for automatic variables>
%  <transfer parameters as needed>
%  <prepare return value>
%  if (!__pr.initial_suspend()) {
%    __resume_f(context);
%  }
%}
%
%void __resume_f(_Context* context) {
%  try {
%  } catch(...) {
%  <handle exception as requiested by the coroutine promise>
%}
%__end:  
%if (__promise.final_suspend()) {
%	<suspend-resume-point>
%	std::terminate();
%}
%<
%}
%\end{codeblock}

\end{quote}