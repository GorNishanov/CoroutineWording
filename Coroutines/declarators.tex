
%%
%% Declarators
%%
\rSec0[dcl.decl]{Declarators}

\setcounter{section}{3}
\setcounter{subsection}{4}
\rSec2[dcl.fct]{Functions}%

%NOTES: Fix
Add paragraph 16.

\begin{quote}
\setcounter{Paras}{15}
\pnum
If the \grammarterm{parameter-declaration-clause} terminates with an ellipsis that is not part of \grammarterm{abstract-declarator}, a function shall not be coroutine (\ref{dcl.fct.def.coroutine}).
\end{quote}

\setcounter{section}{3}
\rSec1[dcl.fct.def]{Function definitions}

\setcounter{subsection}{3}
\rSec2[dcl.fct.def.coroutine]{Coroutines}

Add this section to \ref{dcl.fct.def}.

%\rSec3[coroutine.definitions]{Definitions}
\begin{quote}
\pnum
A function is a \defn{coroutine} if it contains
one or more suspend-resume-points introduced by a potentially-evaluated \grammarterm{await-expression} (\ref{expr.await}).
% implicit NOTE: including implicit
%, or a \tcode{cofor} statement (\ref{stmt.for.await}).
Every coroutine
also has an implicit initial and final suspend-resume point as described later in this section. 

%NOTES: add wording for 

\pnum
\enternote
From the perspective of the caller, a coroutine is just a function with that particular signature. The fact that a function is implemented as a coroutine is unobservable by the caller. 
\exitnote

\pnum
\enterexample
\begin{codeblock}
  // coroutine hello world
  generator<char> hello_fn() {
    for (auto ch: "Hello, world") yield-keyword ch;
  }
  
  int main() {
    // coroutine as a lambda
    auto hello_lambda = []()->generator<char> { 
      for (auto ch: "Hello, world") yield-keyword ch; };
    
    for (auto ch : hello_lambda()) cout << ch;
    for (auto ch : hello_fn()) cout << ch;
  }
\end{codeblock}
\exitexample

\pnum
A coroutine needs a set of related types and functions
to complete the definition of its semantics.
These types and functions are provided as a set of member types or typedefs
and member functions in the specializations of class template
\tcode{std::coroutine_traits} (\ref{coroutine.traits}). 

\pnum
For a coroutine \textit{f}, if 
\textit{f} is a non-static member function, let $P_1$ denote the type of the implicit object parameter (\cxxref{over.match.funcs}) and $P_2$ ... $P_n$ be the types of the function parameters; otherwise let $P_1$ ... $P_n$ be the types of the function parameters.
Let \textit{R} be the return type and \textit{F} be the \grammarterm{function-body}
%\footnote{
%Due to requirement of having suspend-resume points,
%\grammarterm{function-body} is either a
%\grammarterm{compound-statement} or 
%\grammarterm{function-try-block}.
%}
of \textit{f}, \textit{T} be a type \tcode{std::coroutine_traits<$R$,$P_1$,...,$P_n$>}, and \textit{P} be the type denoted by \textit{T::}\tcode{promise_type}. 
%If \textit{T}\tcode{::promise_type} does not refer to a type the program is ill-formed. Type \textit{P} is the \term{promise type} of the coroutine.
Then, the coroutine behaves as if its body were:
\begin{codeblock}
  {
     @\textit{P p}@;
     await-keyword @\textit{p}@.initial_suspend(); // initial suspend point
     @\textit{F'}@
     await-keyword @\textit{p}@.final_suspend(); // final suspend point
  }
\end{codeblock}
where local variable \textit{p} is 
defined for
exposition only and
\textit{F'} is \textit{F}
if \textit{P} does not define a \tcode{set_exception} member function, 
and 
\begin{codeblock}
  try {@\textit{ F }@} catch(...) { @\textit{p}@.set_exception(std::current_exception()); }
\end{codeblock}

otherwise. 
No header needs to be included for this use of the function \tcode{std::current_exception}.
An object denoted as \textit{p} is the \defn{promise object} of
the coroutine \textit{f} and its type is a \defn{promise type}
of the coroutine.
An execution of a coroutine is suspended when it reaches a suspend-resume-point. Implicit \grammarterm{await-expression}{}s introducing initial and final suspend points are not considered \grammarterm{await-expression}{}s for the purpose of type deduction (\ref{dcl.spec.auto}). 

\pnum 
A \defn{suspension} of a coroutine returns control to the current
caller of the coroutine. For the first return of control from the coroutine, the return value is obtained by invoking the member function 
\tcode{get_return_object} (\ref{coroutine.promise})
of the promise object.

%\enternote
%For subsequent suspends, if any, the coroutine
%is invoked via resumption member functions of 
%%NOTE massage
%\tcode{std::coroutine_handle} (\ref{coroutine.handle}) and no return value is expected.
%\exitnote

\pnum
A suspended coroutine can be resumed
to continue execution by invoking
a resumption member functions (\ref{coroutine.handle.resumption}) of an object of \tcode{coroutine_handle<$P$>} type
associated with this instance of the coroutine, where type $P$
is the promise type of the coroutine. Invoking resumption member functions in a coroutine that is not suspended results in undefined behavior. 

\pnum
A coroutine may need to allocate
memory to store objects with automatic storage duration
local to the coroutine. If so, it shall obtain the storage by calling an
\term{allocation function}~(\cxxref{basic.stc.dynamic.allocation}).
The allocation function's name is looked up in the scope of the promise type of the coroutine. If this lookup fails to find the name, the allocation function's name is looked up in the global scope. If the lookup finds an allocation function that takes exactly one parameter, it will be used, otherwise, all parameters passed to the coroutine are passed to the allocation function after the size parameter.
\enternote The second form allows coroutines to support stateful allocators.
\exitnote

\pnum
\enterexample
\begin{codeblock}
  class Arena;
  struct my_coroutine {
    struct promise_type {
      ...
      template <typename... TheRest>
      void* operator new(std::size_t size, Arena* pool, TheRest const&...) {
        return pool.allocate(size);
      }
    };
  };

  my_coroutine (Arena* a) {
    // will call my_coroutine::promise_type::new(<required-size>, a)
    // to obtain storage for the coroutine state
    yield 1;
  }
  
  int main() {
    Pool memPool;
    for (int i = 0; i < 1'000'000; ++i)
      my_coroutine(memPool);
  };
\end{codeblock}
\exitexample

%\pnum
%A coroutine may need to allocate
%memory to store objects with automatic storage duration
%local to the coroutine. If so, it must
%use 
%the allocator object obtained as described in 
%Table~\ref{tab:coroutine.traits.requirements} in clause \ref{coroutine.traits}.

\pnum
A \defn{coroutine state} consists of 
storage for objects with automatic storage duration
that are live at the current point of execution or suspension of 
a coroutine.
The coroutine state is destroyed when
the control flows off the end of the function or
the \tcode{destroy} member function (\ref{coroutine.handle.resumption}) of an object of \tcode{std::coroutine_handle<\textit{P}}> associated with that coroutine is invoked. In the latter case objects with automatic storage duration that are in scope
at the suspend point are destroyed in the reverse order of the construction. If the coroutine state required dynamic allocation, the storage is released by calling a deallocation
function~(\cxxref{basic.stc.dynamic.deallocation}). If \tcode{destroy} is called for a coroutine that is not suspended, the program has undefined behavior.

\pnum
The deallocation function's name is looked up in the scope of the coroutine promise type. If this lookup fails to find the name, the deallocation function's name is looked up in the global scope. If deallocation function lookup finds both a usual deallocation function with only a pointer parameter and a usual deallocation function with both a pointer parameter and a size parameter, then the selected deallocation function shall be the one with two parameters. Otherwise, the selected deallocation function shall be the function with one parameter. 

%introduce metavariable instead of talking about
%coroutine_handle<>

\pnum
When a coroutine is invoked, each of its parameters is copied/moved to the coroutine state, as specified in 12.8.  The copy/move operations are indeterminately sequenced with respect to each other.
A reference to a parameter in the function-body of the coroutine is replaced by a reference to the copy of the parameter.

%\pnum
%An invocation of a coroutine may incur an extra copy/move operation for the parameters.
%%These copies are defined in the same scope as a \term{promise object}. 
%A references to a parameter in the \grammarterm{function-body}
%of the coroutine is replaced by a 
%reference to the copy of the parameter.
%If a parameter copy/move is required, class object moves are performed according to the rules described in \cxxref{class.copy}/28 [class.copy].
%
%\enternote
%This transformation could look as follows:
%
%\begin{codeblock}
%  auto foo(A a, B& b, C&& c, D* d) {
%     A   a' = move(a);
%     B&  b' = b;
%     C&& c' = move(c);
%     D*  d' = d;
%     yield 5; // lifetime of parameters end as per 5.2.2/[expr.call]
%     ...// any parameter mentioned here will refer to its copy
%  } 
%\end{codeblock}
%\exitnote

%\ednote{This is what we currently say about parameters}

%NOTE: massage
%\pnum
%The region of a coroutine state storing parameters to the coroutine is copy-initialized with the parameter values.
%\enternote 
%This copy may be elided (\cxxref{class.copy}).
%\exitnote

%NOTE: say something that we need to check
%Will be moved to coroutine state and can elide the move.
%syntactic constraint will be checked.

%NOTE: eventual-return type not defined anywhere

\pnum
If during the coroutine state initialization, a call to \tcode{get_return_object}, or a promise object construction throws
an exception, objects with automatic storage duration (\cxxref{basic.stc.auto}) that have been
constructed are destroyed in the reverse order of their construction, 
any memory dynamically allocated 
for the coroutine state is freed and the search for a handler starts in the scope of the calling function. 

\pnum
If type \textit{P} defines static member function \tcode{get_return_object_on_allocation_failure} (\ref{coroutine.traits}), then \tcode{std::nothrow_t} forms of allocation and deallocation functions will be used. If an allocation function returns \tcode{nullptr}, coroutine must return control to the caller of the coroutine and the return value shall be obtained by a call to \tcode{P::get_return_object_on_allocation_failure()}.

\enterexample
\begin{codeblock}
struct generator {
  using handle = std::coroutine_handle<promise_type>;
  struct promise_type {
    int current_value;
    static auto get_return_object_on_allocation_failure() { return generator{nullptr}; }
    auto get_return_object() { return generator{handle::from_promise(*this)}; }
    auto initial_suspend() { return std::suspend_always{}; }
    auto final_suspend() { return std::suspend_always{}; }
    auto yield_value(int value) { 
      current_value = value; 
      return std::suspend_always{};
    }
  };
  bool move_next() { return coro ? (coro.resume(), !coro.done()) : false; }
  int current_value() { return coro.promise().current_value; }
  ~generator() { if(coro) coro.destroy(); }
private:
  generator(handle h) : coro(h) {}
  handle coro;
};
generator f() { yield-keyword 1;  yield-keyword 2; }
 
int main() {
  auto g = f();
  while (g.move_next()) std::cout << g.current_value() << std::endl;
}

\end{codeblock}
\exitexample

%\tcode{new(std::size_t,} \tcode{const} \tcode{std::nothrow_t\&)}.
%\enternote
%This provision allows coroutines to be used in environments
%where exception use is not possible to report 
%allocation failures.
%\exitnote

%\pnum A coroutine shall not have an ellipsis parameter specification. 


%\begin{codeblock}
%R f(T1 a, T2 b) {
%  // specialize coroutine_traits to discover customization points
%  using _Traits = std::coroutine_traits<R,T1,T2>;
%  <allocate memory for automatic variables>
%  <transfer parameters as needed>
%  <prepare return value>
%  if (!__pr.initial_suspend()) {
%    __resume_f(context);
%  }
%}
%
%void __resume_f(_Context* context) {
%  try {
%  } catch(...) {
%  <handle exception as requiested by the coroutine promise>
%}
%__end:  
%if (__promise.final_suspend()) {
%	<suspend-resume-point>
%	std::terminate();
%}
%<
%}
%\end{codeblock}

\end{quote}