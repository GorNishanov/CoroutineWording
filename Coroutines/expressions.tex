

\setcounter{chapter}{4}
\rSec0[expr]{Expressions}

\setcounter{section}{2}
\rSec1[expr.unary]{Unary expressions}

%In this section add the \tcode{co_await} \grammarterm{cast-expression} 
%to the rule for \grammarterm{unary-expression}.

Change the grammar for \grammarterm{unary-expression} as follows:

\begin{bnf}
	\nontermdef{unary-expression}\br
	postfix-expression\br
	\terminal{++} cast-expression\br
	\terminal{-{-}} cast-expression\br
	\added{await-expression}\br
	unary-operator cast-expression\br
	\terminal{sizeof} unary-expression\br
	\terminal{sizeof (} type-id \terminal{)}\br
	\terminal{sizeof ...} \terminal{(} identifier \terminal{)}\br
	\terminal{alignof (} type-id \terminal{)}\br
	noexcept-expression\br
	new-expression\br
	delete-expression\br
\end{bnf}

\setcounter{subsection}{6}
\rSec2[expr.unary.noexcept]{\tcode{noexcept} operator}

%NOTES: noexcept
% the resul

% if in a potentially-evaluated context would contain the expression
Add a new paragraph after paragraph 3.

\begin{quote}
\setcounter{Paras}{3}
\pnum
If in a potentially-evaluated context the \textit{expression} would contain a potentially-evaluated \grammarterm{await-expression}, the program is ill-formed.
\end{quote}

\setcounter{subsection}{7}
\rSec2[expr.await]{Await}

Add this section to \ref{expr.unary}.

%NOTES: add quote
\begin{quote}
\pnum
The \tcode{co_await} operator is used to suspend evaluation of the enclosing coroutine (\ref{dcl.fct.def.coroutine}) while awaiting completion of the computation represented by the operand expression.

\begin{bnf}
  \nontermdef{await-expression}\br
  \terminal{co_await} cast-expression
\end{bnf}

\pnum
A potentially-evaluated 
\grammarterm{await-expression} shall only appear within the \grammarterm{compound-statement} of a \grammarterm{function-body} outside of a \grammarterm{handler} (\cxxref{except.handle}).
%
In a \grammarterm{declaration-statement} or in the \grammarterm{simple-declaration} (if any) of a \grammarterm{for-init-statement}, a potentially-evaluated \grammarterm{await-expression} shall only appear in an \grammarterm{initializer} of that \grammarterm{declaration-statement} or \grammarterm{simple-declaration}.
A potentially-evaluated \grammarterm{await-expression} shall not appear in a default argument (\cxxref{dcl.fct.default}).
An \grammarterm{await-expression} shall not appear in a coroutine without an eventual return type (\ref{stmt.return.coroutine}). 
%This constraint does not apply to implicit \grammarterm{await-expression} introduced as a result of evaluation of a \grammarterm{yield-expression} (\ref{expr.yield}), initial, and final suspend points (\ref{dcl.fct.def.coroutine}).

\pnum
Let \textit{f} be the \tcode{operator co_await} function selected by overload resolution for \grammarterm{cast-expression} as the argument. 
If there is no viable function, let $e$ be the \textit{cast-expression}, otherwise $e$ is a temporary initialized as-if by \tcode{auto\&\& e = \textit{f(cast-expression)}}.
Let \textit{p} be the promise object (\ref{dcl.fct.def.coroutine})
of the enclosing coroutine, \textit{P} be the type of the promise object, \textit{h} be an object of type  \tcode{std::coroutine_handle<\textit{P}>} referring to the enclosing coroutine, then


\begin{ncbnf}
  \terminal{co_await} cast-expression
\end{ncbnf}
is equivalent to:

\begin{codeblock}
  @$e$@.await_ready() ? @$e$@.await_resume() : (@$e$@.await_suspend(@$h$@), @\textit{S}@, @$e$@.await_resume())
\end{codeblock}
where $S$ is a coroutine-suspend-point (\ref{dcl.fct.def.coroutine}) treated as an expression of type tcode{void}.

\pnum
A coroutine is considered suspended immediately prior to  the invocation of \tcode{$e$.await_suspend($h$)}. If the type of the expression \tcode{$e$.await_suspend($h$)} is \tcode{bool} and the invocation of \tcode{$e$.await_suspend($h$)} returns \tcode{false}, or the invocation of \tcode{$e$.await_suspend($h$)} exits via an exception, execution continues as if coroutine were resumed. 

%If  exception thrown from within \textit{await-suspend-expr} is propagated as if coroutine was resumed and an exception was thrown just prior to an invocation of \textit{await-resume-expr}.

\pnum
\enternote
An \grammarterm{await-expression} may appear as an unevaluated operand (Clause \ref{expr}). 
\enterexample
\begin{codeblock}	
  std::future<int> f();
  
  int main() {
    using t = decltype(co_await f()); // t is int
    static_assert(sizeof(co_await f()) == sizeof(int));
    cout << typeid(co_await f()).name() << endl;
  }
\end{codeblock}
\exitexample%
\exitnote

\end{quote}
%, i.e a coroutine shall have the \tcode{return_value} or \tcode{return_void} member
%functions defined in its \term{promise type} 
%
%\rSec2[expr.await.old]{Old version of Coawait for wording comparison}
%
%\pnum
%A \tcode{await} expression of the form
%
%\begin{ncbnf}
%	\terminal{co_await} cast-expression
%\end{ncbnf}
%is equivalent to \footnote{if it were possible to write
%an expression in terms of a block, where return from the 
%block becomes the result of the expression}
%
%\begin{codeblock}
%{
%  auto && __expr = @\grammarterm{cast-expression}@;
%  if ( !@\textit{await-ready-expr}@ ) {
%    @\textit{await-suspend-expr}@;
%    @\textit{suspend-resume point}@
%  }
%  return await-resume-expr;
%}
%\end{codeblock}
%
%otherwise, the await expression is equivalent
%
%%NOTE:
%%The type, value category and value of an await expression are those of \texit{await-resume-expr}.
%
%%NOTE: try rewriting that so that definitions come first
%
%%NOTE: start with if
%
%% otherwise, the await expression is equivalent
%
%%drop the footnote
%
%% NOTE: add that await expression cannot be a constexpr to the list of things that cannot be a constexpr
%
%% new wording
%%await cast-expression executes as if "block" and return of that an await expression is.
%
%
%if the type of \textit{await-suspend-expr} is \tcode{void}, otherwise it is equivalent to
%
%\begin{codeblock}
%{
%  auto && __expr = @\grammarterm{cast-expression}@;
%  if ( !await-ready-expr && await-suspend-expr ) {
%    @\textit{suspend-resume-point}@
%  }
%  return await-resume-expr;
%}
%\end{codeblock}
%
%where \tcode{__expr} is a variable defined for
%exposition only, and \tcode{_ExprT} is the type of the
%\grammarterm{cast-expression}, and \tcode{_PromiseT} is the 
%promise type of the enclosing coroutine,
%and \tcode{_CoroutineHandle}
%is an object of the type \tcode{std::coroutine_handle<_PromiseT>} (\ref{coroutine.handle}) corresponding to the enclosing function,
%%NOTES add reference to promise
%and \textit{await-ready-expr}, \textit{await-suspend-expr}, and \textit{await-expr} are
%determined as follows:
%
%% _ExprT == T
%% _CoroutineHandle == c
%
%\begin{itemize}
%	\item if the type of the \textit{cast-expression} is a class type, the \grammarterm{unqualified-id}{s}
%	\tcode{await_ready}, \tcode{await_suspend}, and \tcode{await_resume} are 
%	looked up in the scope of that class
%	as if by class member access lookup~(\cxxref{basic.lookup.classref}), and if it finds at least one declaration, 
%	\textit{await-ready}, \textit{await-suspend}, and \textit{await-resume} are
%	\tcode{__expr.await_ready()}, \tcode{__expr.await_suspend(_CoroutineHandle)} and \tcode{__expr.await_resume()},
%	respectively;
%	
%	\item otherwise, \textit{await-ready}, \textit{await-suspend} and \textit{await-resume} are 
%	\tcode{await_ready(__expr)}, \tcode{await_suspend(__expr, _CoroutineHandle)}, and \tcode{await_resume(__expr)} 
%	respectively, where 
%	\textit{await-ready}, \textit{await-suspend}, and \textit{await-resume} are 
%	looked up in the associated namespaces~(\cxxref{basic.lookup.argdep}).
%	\enternote Ordinary unqualified lookup~(\cxxref{basic.lookup.unqual}) is not
%	performed. \exitnote
%\end{itemize}
%
%%\enterexample
%%\begin{codeblock}
%%	int result = await async([]{return 5;});
%%\end{codeblock}
%%\exitexample%

\setcounter{section}{17}
\rSec1[expr.ass]{Assignment and compound assignment operators}%

%In paragraph 1, 
Add \grammarterm{yield-expression} to the grammar production \grammarterm{assignment-expression}.

\begin{quote}
\begin{bnf}
  \nontermdef{assignment-expression}\br
  conditional-expression\br
  logical-or-expression assignment-operator initializer-clause\br
  throw-expression \br
  \added{yield-expression}
\end{bnf}
\end{quote}

\setcounter{section}{20}
\rSec1[expr.yield]{Yield expressions}%

Add a new section to Clause \ref{expr}.

\begin{quote}
\begin{bnf}
  \nontermdef{yield-expression}\br
  \terminal{co_yield} assignment-expression\br
  \terminal{co_yield} braced-init-list
\end{bnf}

\pnum
  Let \textit{e} be the operand of the \grammarterm{yield-expression} and \textit{p} be the promise object of the enclosing coroutine, then the \grammarterm{yield-expression} is equivalent to the expression \tcode{co_await} \textit{p}\tcode{.yield_value}(\textit{e}).
  % If coroutine promise does not define a function \tcode{yield_value}, the program is ill-formed.
% An implicit \grammarterm{await-expression} introduced by this evaluation is not considered an \grammarterm{await-expression} for the purpose of type deduction (\ref{dcl.spec.auto}). 

%\pnum
%\enterexample
%\begin{codeblock}
%using namespace std;
%  
%generator<pair<int,int>> g1() {
%  for (int i = i; i < 10; ++i)
%    co_yield {i,i};
%}
%
%int main() {
%  auto r1 = g1();
%  auto r2 = g2();
%  assert(equal(r1.begin(), r1.end(), r2.begin(), r2.end()));
%}
%\end{codeblock}
%auto g2() { // deduces to generator<pair<int,int>{}>
%  for (int i = i; i < 10; ++i)
%  co_yield make_pair(i,i);
%}
%\exitexample
%
%\pnum
%All restrictions on where an \textit{await-expression} can appear apply to \textit{yield-expression}{}s.
%
%\enterexample
%\begin{codeblock}
%  auto f(int x = yield 5); // ill-formed
%  int a[] = { yield 1 }; // ill-formed
%\end{codeblock}
%\exitexample


\end{quote}

