

\setcounter{chapter}{4}
\rSec0[expr]{Expressions}

\setcounter{section}{2}
\rSec1[expr.unary]{Unary expressions}

%In this section add the \tcode{await-keyword} \grammarterm{cast-expression} 
%to the rule for \grammarterm{unary-expression}.

In this section change the grammar for \grammarterm{unary-expression} as follows:

\begin{bnf}
	\nontermdef{unary-expression}\br
	postfix-expression\br
	\terminal{++} cast-expression\br
	\terminal{-{-}} cast-expression\br
%	\added{\terminal{await-keyword} cast-expression}\br
	\added{await-expression}\br
	unary-operator cast-expression\br
	\terminal{sizeof} unary-expression\br
	\terminal{sizeof (} type-id \terminal{)}\br
	\terminal{sizeof ...} \terminal{(} identifier \terminal{)}\br
	\terminal{alignof (} type-id \terminal{)}\br
	noexcept-expression\br
	new-expression\br
	delete-expression\br
\end{bnf}

\setcounter{subsection}{6}
\rSec2[expr.unary.noexcept]{\tcode{noexcept} operator}

%NOTES: noexcept
% the resul

% if in a potentially-evaluated context would contain the expression
In this section, add a new paragraph after paragraph 3.

\begin{quote}
\setcounter{Paras}{3}
\pnum
If in a potentially-evaluated context the \textit{expression} would contain a potentially-evaluated \grammarterm{await-expression}, the program is ill-formed.
\end{quote}

\setcounter{subsection}{7}
\rSec2[expr.await]{Await}

Add this section to \ref{expr.unary}.

%NOTES: add quote
\begin{quote}
\pnum
The \tcode{await-keyword} operator is used to suspend evaluation of the enclosing coroutine (\ref{dcl.fct.def.coroutine}) while awaiting completion of the computation represented by the operand expression.

\begin{bnf}
  \nontermdef{await-expression}\br
  \terminal{await-keyword} cast-expression
\end{bnf}

\pnum
A potentially-evaluated 
\grammarterm{await-expression} shall only appear within the \grammarterm{compound-statement} of a \grammarterm{function-body} outside of a \grammarterm{handler} (\cxxref{except.handle}).
%
In a \grammarterm{declaration-statement} or in the \grammarterm{simple-declaration} (if any) of a \grammarterm{for-init-statement}, a potentially-evaluated \grammarterm{await-expression} shall only appear in an \grammarterm{initializer} of that \grammarterm{declaration-statement} or \grammarterm{simple-declaration}.
%
%A potentially-evaluated \tcode{await-keyword} expression shall not appear in a
%local class defined in \grammarterm{declaration-statement}.
%
A potentially-evaluated \grammarterm{await-expression} shall not appear in a default argument (\cxxref{dcl.fct.default}).

\pnum
Let \textit{f} be an \tcode{operator await} function found according to the rules of operator function lookup for unary operators and \tcode{operator await}(\ref{over.await}) for \textit{cast-expression}. If such a function cannot be found, the program is ill-formed. 
Let $e$ be a temporary initialized as-if by \tcode{auto\&\& e = \textit{f(cast-expression)}}; let \textit{p} be the promise object (\ref{dcl.fct.def.coroutine})
of the enclosing coroutine, \textit{P} be the type of the promise object, \textit{h} be an object of type  \tcode{std::coroutine_handle<\textit{P}>} referring to the enclosing coroutine, and let \textit{await-ready-expr}, \textit{await-suspend-expr}, and \textit{await-resume-expr} be
\tcode{\textit{e}.await_ready()}, \tcode{\textit{e}.await_suspend(\textit{h})}, and \tcode{\textit{e}.await_resume()}, respectively;

%If the type of \textit{e.await_suspend(h)} is \tcode{bool}, then
%
%\begin{ncbnf}
%  \terminal{await-keyword} cast-expression
%\end{ncbnf}
%is equivalent to:
%
%\begin{codeblock}
%  (
%  (@\textit{await-ready-expr}@ && !@\textit{await-suspend-expr}@) ? @\textit{await-resume-expr}@
%  : (@\textit{suspend-resume-point}@, @\textit{await-resume-expr}@)
%  )
%\end{codeblock}
%otherwise, it is equivalent to:

then

\begin{ncbnf}
  \terminal{await-keyword} cast-expression
\end{ncbnf}
is equivalent to:

\begin{codeblock}
  (
  @\textit{await-ready-expr}@ ? @\textit{await-resume-expr}@
  : (@\textit{await-suspend-expr}@, @\textit{suspend-resume-point}@, @\textit{await-resume-expr}@)
  )
\end{codeblock}


%\pnum
%Let \textit{T} be the type of the \grammarterm{cast-expression}.
%If \textit{T} is a class type, and if at least one of the \grammarterm{unqualified-id}{s}
%\tcode{await_ready}, \tcode{await_suspend}, 
%\tcode{await_resume} are found in the scope of that class as if by class member access lookup~(\cxxref{basic.lookup.classref}), and if it finds at least one declaration, 
%If the \grammarterm{cast-expression} is a prvalue, let $e$ be a temporary initialized as-if by \tcode{T e = \textit{cast-expression}}; otherwise let \textit{e} be an lvalue designating the value of the \grammarterm{cast-expression}.
%Let \textit{p} be the promise object (\ref{dcl.fct.def.coroutine})
%of the enclosing coroutine, \textit{P} be the type of the promise object, \textit{h} be an object of \tcode{std::coroutine_handle<\textit{P}>} referring to the enclosing coroutine, then \textit{await-ready-expr}, \textit{await-suspend-expr}, and \textit{await-resume-expr} are expressions defined as follows:
%\begin{itemize}
%  %CHECK oxfor comma
%  \item if \textit{T}  is a class type, the \grammarterm{unqualified-id}{s}
%  \tcode{await_ready}, \tcode{await_suspend}, 
%   \tcode{await_resume} are 
%  looked up in the scope of that class
%  as if by class member access lookup~(\cxxref{basic.lookup.classref}), and if it finds at least one declaration, 
%  \textit{await-ready-expr}, \textit{await-suspend-expr}, and \textit{await-resume-expr} are
%  \tcode{\textit{e}.await_ready()}, \tcode{\textit{e}.await_suspend(\textit{h})}, and \tcode{\textit{e}.await_resume()},
%  respectively;
%  
%  \item otherwise, \textit{await-ready-expr}, \textit{await-suspend-expr}, and \textit{await-resume-expr} are 
%  \tcode{await_ready(\textit{e})}, 
%  \tcode{await_suspend(\textit{e}, \textit{h})}, and \tcode{await_resume(\textit{e})} 
%  respectively, where 
%  \textit{await-ready-expr}, \textit{await-suspend-expr}, and \textit{await-resume-expr} are 
%  looked up in the associated namespaces~(\cxxref{basic.lookup.argdep}).
%  \enternote Ordinary unqualified lookup~(\cxxref{basic.lookup.unqual}) is not
%  performed. \exitnote
%\end{itemize}
%
%%style cv-void
%If the type of \textit{await-suspend-expr} is \cvvoid, then
%
%\begin{ncbnf}
%  \terminal{await-keyword} cast-expression
%\end{ncbnf}
%is equivalent to:
%%refactor
%\begin{codeblock}
%(
%    @\textit{await-ready-expr}@ ? @\textit{await-resume-expr}@
%    : (@\textit{await-suspend-expr}@, @\textit{suspend-resume-point}@, @\textit{await-resume-expr}@)
%)
%\end{codeblock}
%
%otherwise, it is equivalent to:
%
%\begin{codeblock}
%(
%    (@\textit{await-ready-expr}@ && !@\textit{await-suspend-expr}@) ? @\textit{await-resume-expr}@
%    : (@\textit{suspend-resume-point}@, @\textit{await-resume-expr}@)
%)
%\end{codeblock}

where \textit{suspend-resume-point}s are treated as  expressions of type \tcode{void}. Suspend-resume-points are defined in (\ref{dcl.fct.def.coroutine}).
%NOTE:

\pnum
An \grammarterm{await-expression} may only appear in a coroutine 
with an eventual return type (\ref{stmt.return.coroutine}). This constraint does not apply to implicit \grammarterm{await-expression} introduced as a result of evaluation of a \grammarterm{yield-expression} (\ref{expr.yield}), initial, and final suspend points (\ref{dcl.fct.def.coroutine}).

\pnum
A coroutine is considered suspended immediately prior to  \textit{await-suspend-expr}. If the return type of \textit{await-suspend-expr} is \tcode{bool} and invocation of \textit{await-suspend-expr} returns \tcode{false}, then execution continues as if coroutine was resumed. An exception thrown from within \textit{await-suspend-expr} is propagated as if coroutine was resumed and an exception was thrown just prior to an invocation of \textit{await-resume-expr}.

\pnum
\enternote
An \grammarterm{await-expression} may appear as an unevaluated operand (\cxxref{expr.typeid}, \cxxref{expr.sizeof}, \cxxref{expr.unary.noexcept}, \cxxref{dcl.type.simple}). The presence of such an \grammarterm{await-expression} does not make the enclosing function a coroutine and can be used to examine the type of an \grammarterm{await-expression}.

\enterexample
\begin{codeblock}	
  std::future<int> f();
  
  int main() {
    using t = decltype(await-keyword f()); // t is int
    static_assert(sizeof(await-keyword f()) == sizeof(int));
    cout << typeid(await-keyword f()).name() << endl;
  }
\end{codeblock}
\exitexample%
\exitnote

\end{quote}
%, i.e a coroutine shall have the \tcode{return_value} or \tcode{return_void} member
%functions defined in its \term{promise type} 
%
%\rSec2[expr.await.old]{Old version of Coawait for wording comparison}
%
%\pnum
%A \tcode{await} expression of the form
%
%\begin{ncbnf}
%	\terminal{await-keyword} cast-expression
%\end{ncbnf}
%is equivalent to \footnote{if it were possible to write
%an expression in terms of a block, where return from the 
%block becomes the result of the expression}
%
%\begin{codeblock}
%{
%  auto && __expr = @\grammarterm{cast-expression}@;
%  if ( !@\textit{await-ready-expr}@ ) {
%    @\textit{await-suspend-expr}@;
%    @\textit{suspend-resume point}@
%  }
%  return await-resume-expr;
%}
%\end{codeblock}
%
%otherwise, the await expression is equivalent
%
%%NOTE:
%%The type, value category and value of an await expression are those of \texit{await-resume-expr}.
%
%%NOTE: try rewriting that so that definitions come first
%
%%NOTE: start with if
%
%% otherwise, the await expression is equivalent
%
%%drop the footnote
%
%% NOTE: add that await expression cannot be a constexpr to the list of things that cannot be a constexpr
%
%% new wording
%%await cast-expression executes as if "block" and return of that an await expression is.
%
%
%if the type of \textit{await-suspend-expr} is \tcode{void}, otherwise it is equivalent to
%
%\begin{codeblock}
%{
%  auto && __expr = @\grammarterm{cast-expression}@;
%  if ( !await-ready-expr && await-suspend-expr ) {
%    @\textit{suspend-resume-point}@
%  }
%  return await-resume-expr;
%}
%\end{codeblock}
%
%where \tcode{__expr} is a variable defined for
%exposition only, and \tcode{_ExprT} is the type of the
%\grammarterm{cast-expression}, and \tcode{_PromiseT} is the 
%promise type of the enclosing coroutine,
%and \tcode{_CoroutineHandle}
%is an object of the type \tcode{std::coroutine_handle<_PromiseT>} (\ref{coroutine.handle}) corresponding to the enclosing function,
%%NOTES add reference to promise
%and \textit{await-ready-expr}, \textit{await-suspend-expr}, and \textit{await-expr} are
%determined as follows:
%
%% _ExprT == T
%% _CoroutineHandle == c
%
%\begin{itemize}
%	\item if the type of the \textit{cast-expression} is a class type, the \grammarterm{unqualified-id}{s}
%	\tcode{await_ready}, \tcode{await_suspend}, and \tcode{await_resume} are 
%	looked up in the scope of that class
%	as if by class member access lookup~(\cxxref{basic.lookup.classref}), and if it finds at least one declaration, 
%	\textit{await-ready}, \textit{await-suspend}, and \textit{await-resume} are
%	\tcode{__expr.await_ready()}, \tcode{__expr.await_suspend(_CoroutineHandle)} and \tcode{__expr.await_resume()},
%	respectively;
%	
%	\item otherwise, \textit{await-ready}, \textit{await-suspend} and \textit{await-resume} are 
%	\tcode{await_ready(__expr)}, \tcode{await_suspend(__expr, _CoroutineHandle)}, and \tcode{await_resume(__expr)} 
%	respectively, where 
%	\textit{await-ready}, \textit{await-suspend}, and \textit{await-resume} are 
%	looked up in the associated namespaces~(\cxxref{basic.lookup.argdep}).
%	\enternote Ordinary unqualified lookup~(\cxxref{basic.lookup.unqual}) is not
%	performed. \exitnote
%\end{itemize}
%
%%\enterexample
%%\begin{codeblock}
%%	int result = await async([]{return 5;});
%%\end{codeblock}
%%\exitexample%

\setcounter{section}{17}
\rSec1[expr.ass]{Assignment and compound assignment operators}%

In paragraph 1, add \grammarterm{yield-expression} to the grammar production \grammarterm{assignment-expression}.

\begin{quote}
\begin{bnf}
  \nontermdef{assignment-expression}\br
  conditional-expression\br
  logical-or-expression assignment-operator initializer-clause\br
  throw-expression \br
  \added{yield-expression}
\end{bnf}
\end{quote}

\setcounter{section}{20}
\rSec1[expr.yield]{Yield expressions}%

Add a new section to Clause \ref{expr}.

\begin{quote}
\begin{bnf}
  \nontermdef{yield-expression}\br
  \terminal{yield-keyword} assignment-expression\br
  \terminal{yield-keyword} braced-init-list
\end{bnf}

\pnum
  Let \textit{e} be the operand of the \grammarterm{yield-expression} and \textit{p} be the promise object of the enclosing coroutine, then the \grammarterm{yield-expression} is equivalent to the expression \tcode{await-keyword} \textit{p}\tcode{.yield_value}(\textit{e}).
  % If coroutine promise does not define a function \tcode{yield_value}, the program is ill-formed.
% An implicit \grammarterm{await-expression} introduced by this evaluation is not considered an \grammarterm{await-expression} for the purpose of type deduction (\ref{dcl.spec.auto}). 

%\pnum
%\enterexample
%\begin{codeblock}
%using namespace std;
%  
%generator<pair<int,int>> g1() {
%  for (int i = i; i < 10; ++i)
%    yield-keyword {i,i};
%}
%
%int main() {
%  auto r1 = g1();
%  auto r2 = g2();
%  assert(equal(r1.begin(), r1.end(), r2.begin(), r2.end()));
%}
%\end{codeblock}
%auto g2() { // deduces to generator<pair<int,int>{}>
%  for (int i = i; i < 10; ++i)
%  yield-keyword make_pair(i,i);
%}
%\exitexample
%
%\pnum
%All restrictions on where an \textit{await-expression} can appear apply to \textit{yield-expression}{}s.
%
%\enterexample
%\begin{codeblock}
%  auto f(int x = yield 5); // ill-formed
%  int a[] = { yield 1 }; // ill-formed
%\end{codeblock}
%\exitexample


\end{quote}

