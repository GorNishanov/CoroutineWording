

\setcounter{chapter}{4}
\rSec0[expr]{Expressions}

\setcounter{section}{2}
\rSec1[expr.unary]{Unary expressions}

%In this section add the \tcode{co_await} \grammarterm{cast-expression} 
%to the rule for \grammarterm{unary-expression}.

Change the grammar for \grammarterm{unary-expression} as follows:

\begin{bnf}
	\nontermdef{unary-expression}\br
	postfix-expression\br
	\terminal{++} cast-expression\br
	\terminal{-{-}} cast-expression\br
	\added{await-expression}\br
	unary-operator cast-expression\br
	\terminal{sizeof} unary-expression\br
	\terminal{sizeof (} type-id \terminal{)}\br
	\terminal{sizeof ...} \terminal{(} identifier \terminal{)}\br
	\terminal{alignof (} type-id \terminal{)}\br
	noexcept-expression\br
	new-expression\br
	delete-expression\br
\end{bnf}

\setcounter{subsection}{6}
\rSec2[expr.unary.noexcept]{\tcode{noexcept} operator}

%NOTES: noexcept
% the resul

% if in a potentially-evaluated context would contain the expression
Add a new paragraph after paragraph 3.

\begin{quote}
\setcounter{Paras}{3}
\pnum
If in a potentially-evaluated context the \textit{expression} would contain a potentially-evaluated \grammarterm{await-expression}, the program is ill-formed.
\end{quote}

\setcounter{subsection}{7}
\rSec2[expr.await]{Await}

Add this section to \ref{expr.unary}.

%NOTES: add quote
\begin{quote}
\pnum
The \tcode{co_await} operator is used to suspend evaluation of the enclosing coroutine (\ref{dcl.fct.def.coroutine}) while awaiting completion of the computation represented by the operand expression.

\begin{bnf}
  \nontermdef{await-expression}\br
  \terminal{co_await} cast-expression
\end{bnf}

\pnum
A potentially-evaluated 
\grammarterm{await-expression} shall only appear within the \grammarterm{compound-statement} of a \grammarterm{function-body} outside of a \grammarterm{handler} (\cxxref{except.handle}).
%
In a \grammarterm{declaration-statement} or in the \grammarterm{simple-declaration} (if any) of a \grammarterm{for-init-statement}, a potentially-evaluated \grammarterm{await-expression} shall only appear in an \grammarterm{initializer} of that \grammarterm{declaration-statement} or \grammarterm{simple-declaration}.
A potentially-evaluated \grammarterm{await-expression} shall not appear in a default argument (\cxxref{dcl.fct.default}).
%An \grammarterm{await-expression} shall not appear in a coroutine without an eventual return type (\ref{stmt.return.coroutine}). 
%This constraint does not apply to implicit \grammarterm{await-expression} introduced as a result of evaluation of a \grammarterm{yield-expression} (\ref{expr.yield}), initial, and final suspend points (\ref{dcl.fct.def.coroutine}).

\pnum
Evaluation of an \grammarterm{await-expression} involves the following auxiliary expressions:

\begin{itemize}
  \item If the \grammarterm{cast-expression} is a prvalue, $a$ is a temporary object copy-initialized from the \grammarterm{cast-expression}, otherwise $a$ is an lvalue referring to the result of evaluating the \grammarterm{cast-expression}.
  \item $p$ is an lvalue naming the promise object (8.4.4) of the enclosing coroutine.
  \item If the \grammarterm{await-expression} is potentially-evaluated and lookup for the unqualified-id \tcode{await_transform} within the scope of \tcode{decltype($p$)} as if by class member access lookup (3.4.5) finds at least one declaration, then $e$ is \tcode{$p$.await_transform(a);} otherwise, $e$ is $a$.
  \item $h$ is an object of type \tcode{decltype(std::coroutine_handle<decltype($p$)>} referring to the enclosing coroutine.
  \item \textit{await-ready} is the expression \tcode{$e$.await_ready()}, contextually converted to \tcode{bool}.
  \item \textit{await-suspend} is the expression \tcode{$e$.await_suspend($h$)}, which shall be a prvalue of type \tcode{void} or \tcode{bool}.
  \item \textit{await-resume} is the expression \tcode{$e$.await_resume()}.
\end{itemize}
In an unevaluated operand, only the expressions $a$, $e$, and \textit{await-resume} are required to be valid, and the \grammarterm{await-expression} is equivalent to the \textit{await-resume} expression.

\pnum The \grammarterm{await-expression} has the same type and value category as the \tcode{await-resume} expression.

\pnum The \grammarterm{await-expression} evaluates the \textit{await-ready} expression, then:
\begin{itemize}
  \item If the result is \tcode{true}, a suspend-resume point (8.4.4) is evaluated. After that evaluation and before control flow returns to the current caller or resumer (TODO: define this somewhere) of the coroutine, the \textit{await-suspend} expression is evaluated. If that expression has type \tcode{bool} and returns \tcode{false}, the coroutine is resumed. If that expression exits via an exception, the exception is caught, the coroutine is resumed, and the exception is immediately re-thrown (15.1). Otherwise, control flow returns to the current caller or resumer.
  \item If the result is \tcode{false}, or when the coroutine is resumed, the \textit{await-resume} expression is evaluated, and its result is the result of the \grammarterm{await-expression}.
  
\end{itemize}

\pnum
\enternote
An \grammarterm{await-expression} may appear as an unevaluated operand (Clause \ref{expr}). 
\enterexample
\begin{codeblock}	
template <typename T>
struct my_future {
  ...
  bool await_ready();
  void await_suspend(std::coroutine_handle<>);
  T await_resume();
};
my_future<int> f();
  
template <class Rep, class Period>
auto operator co_await(std::chrono::duration<Rep, Period> d) {
  struct awaiter {
    std::chrono::system_clock::duration duration;
    ...
    awaiter(std::chrono::system_clock::duration d) : duration(d){}
    bool await_ready() const { return duration.count() <= 0; }
    void await_resume() {}
    void await_suspend(std::coroutine_handle<> h){...}
  };
  return awaiter{d};
}

int main() {
  using t = decltype(co_await f()); // t is int
  static_assert(sizeof(co_await f()) == sizeof(int));
  std::cout << typeid(co_await f()).name() << std::endl; // outputs: int
  std::cout << typeid(co_await 1ms).name() << std::endl; // outputs: void
}
\end{codeblock}
\exitexample%
\exitnote

\end{quote}
%, i.e a coroutine shall have the \tcode{return_value} or \tcode{return_void} member
%functions defined in its \term{promise type} 
%
%\rSec2[expr.await.old]{Old version of Coawait for wording comparison}
%
%\pnum
%A \tcode{await} expression of the form
%
%\begin{ncbnf}
%	\terminal{co_await} cast-expression
%\end{ncbnf}
%is equivalent to \footnote{if it were possible to write
%an expression in terms of a block, where return from the 
%block becomes the result of the expression}
%
%\begin{codeblock}
%{
%  auto && __expr = @\grammarterm{cast-expression}@;
%  if ( !@\textit{await-ready-expr}@ ) {
%    @\textit{await-suspend-expr}@;
%    @\textit{suspend-resume point}@
%  }
%  return await-resume-expr;
%}
%\end{codeblock}
%
%otherwise, the await expression is equivalent
%
%%NOTE:
%%The type, value category and value of an await expression are those of \texit{await-resume-expr}.
%
%%NOTE: try rewriting that so that definitions come first
%
%%NOTE: start with if
%
%% otherwise, the await expression is equivalent
%
%%drop the footnote
%
%% NOTE: add that await expression cannot be a constexpr to the list of things that cannot be a constexpr
%
%% new wording
%%await cast-expression executes as if "block" and return of that an await expression is.
%
%
%if the type of \textit{await-suspend-expr} is \tcode{void}, otherwise it is equivalent to
%
%\begin{codeblock}
%{
%  auto && __expr = @\grammarterm{cast-expression}@;
%  if ( !await-ready-expr && await-suspend-expr ) {
%    @\textit{suspend-resume-point}@
%  }
%  return await-resume-expr;
%}
%\end{codeblock}
%
%where \tcode{__expr} is a variable defined for
%exposition only, and \tcode{_ExprT} is the type of the
%\grammarterm{cast-expression}, and \tcode{_PromiseT} is the 
%promise type of the enclosing coroutine,
%and \tcode{_CoroutineHandle}
%is an object of the type \tcode{std::coroutine_handle<_PromiseT>} (\ref{coroutine.handle}) corresponding to the enclosing function,
%%NOTES add reference to promise
%and \textit{await-ready-expr}, \textit{await-suspend-expr}, and \textit{await-expr} are
%determined as follows:
%
%% _ExprT == T
%% _CoroutineHandle == c
%
%\begin{itemize}
%	\item if the type of the \textit{cast-expression} is a class type, the \grammarterm{unqualified-id}{s}
%	\tcode{await_ready}, \tcode{await_suspend}, and \tcode{await_resume} are 
%	looked up in the scope of that class
%	as if by class member access lookup~(\cxxref{basic.lookup.classref}), and if it finds at least one declaration, 
%	\textit{await-ready}, \textit{await-suspend}, and \textit{await-resume} are
%	\tcode{__expr.await_ready()}, \tcode{__expr.await_suspend(_CoroutineHandle)} and \tcode{__expr.await_resume()},
%	respectively;
%	
%	\item otherwise, \textit{await-ready}, \textit{await-suspend} and \textit{await-resume} are 
%	\tcode{await_ready(__expr)}, \tcode{await_suspend(__expr, _CoroutineHandle)}, and \tcode{await_resume(__expr)} 
%	respectively, where 
%	\textit{await-ready}, \textit{await-suspend}, and \textit{await-resume} are 
%	looked up in the associated namespaces~(\cxxref{basic.lookup.argdep}).
%	\enternote Ordinary unqualified lookup~(\cxxref{basic.lookup.unqual}) is not
%	performed. \exitnote
%\end{itemize}
%
%%\enterexample
%%\begin{codeblock}
%%	int result = await async([]{return 5;});
%%\end{codeblock}
%%\exitexample%

\setcounter{section}{17}
\rSec1[expr.ass]{Assignment and compound assignment operators}%

%In paragraph 1, 
Add \grammarterm{yield-expression} to the grammar production \grammarterm{assignment-expression}.

\begin{quote}
\begin{bnf}
  \nontermdef{assignment-expression}\br
  conditional-expression\br
  logical-or-expression assignment-operator initializer-clause\br
  throw-expression \br
  \added{yield-expression}
\end{bnf}
\end{quote}

\setcounter{section}{20}
\rSec1[expr.yield]{Yield expressions}%

Add a new section to Clause \ref{expr}.

\begin{quote}
\begin{bnf}
  \nontermdef{yield-expression}\br
  \terminal{co_yield} assignment-expression\br
  \terminal{co_yield} braced-init-list
\end{bnf}

\pnum
  Let \textit{e} be the operand of the \grammarterm{yield-expression} and \textit{p} be the promise object of the enclosing coroutine, then the \grammarterm{yield-expression} is equivalent to the expression \tcode{co_await} \textit{p}\tcode{.yield_value}(\textit{e}).
  % If coroutine promise does not define a function \tcode{yield_value}, the program is ill-formed.
% An implicit \grammarterm{await-expression} introduced by this evaluation is not considered an \grammarterm{await-expression} for the purpose of type deduction (\ref{dcl.spec.auto}). 

%\pnum
%\enterexample
%\begin{codeblock}
%using namespace std;
%  
%generator<pair<int,int>> g1() {
%  for (int i = i; i < 10; ++i)
%    co_yield {i,i};
%}
%
%int main() {
%  auto r1 = g1();
%  auto r2 = g2();
%  assert(equal(r1.begin(), r1.end(), r2.begin(), r2.end()));
%}
%\end{codeblock}
%auto g2() { // deduces to generator<pair<int,int>{}>
%  for (int i = i; i < 10; ++i)
%  co_yield make_pair(i,i);
%}
%\exitexample
%
%\pnum
%All restrictions on where an \textit{await-expression} can appear apply to \textit{yield-expression}{}s.
%
%\enterexample
%\begin{codeblock}
%  auto f(int x = yield 5); // ill-formed
%  int a[] = { yield 1 }; // ill-formed
%\end{codeblock}
%\exitexample


\end{quote}

