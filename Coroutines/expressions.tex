

\setcounter{chapter}{4}
\rSec0[expr]{Expressions}

\setcounter{section}{2}
\rSec1[expr.unary]{Unary expressions}

In this section add the \tcode{await} \grammarterm{cast-expression} 
to the rule for \grammarterm{unary-expression}.

\begin{bnf}
	\nontermdef{unary-expression}\br
	postfix-expression\br
	\terminal{++} cast-expression\br
	\terminal{-{-}} cast-expression\br
	\added{\terminal{await} cast-expression}\br
	unary-operator cast-expression\br
	\terminal{sizeof} unary-expression\br
	\terminal{sizeof (} type-id \terminal{)}\br
	\terminal{sizeof ...} \terminal{(} identifier \terminal{)}\br
	\terminal{alignof (} type-id \terminal{)}\br
	noexcept-expression\br
	new-expression\br
	delete-expression\br
\end{bnf}

Add subsection 5.3.9.

\setcounter{subsection}{8}
\rSec2[expr.await]{Await}

\pnum
The await operator is used to suspend evaluation of the enclosing resumable function.

\pnum
Presence of an await operator in a potentially-evaluated expression makes enclosing function a resumable function.

\pnum
The await operator shall not appear in a potentially-evaluated expression in a catch clause of a try block.

%\rSec2[expr.await.evaluation]{Evaluation of await operator}

\pnum
An \tcode{await} expression of the form

\begin{ncbnf}
	\terminal{await} cast-expression
\end{ncbnf}

is equivalent to \footnote{it it were possible to write
an expression in terms of a block, where return from the 
block becomes the result of the expression}

\begin{codeblock}
{
  auto && __expr = cast-expression;
  if ( !await-ready-expr ) {
    await-suspend-expr;
    suspend-resume-point
  }
  return await-resume-expr;
}
\end{codeblock}

if the type of \textit{await-suspend-expr} is \tcode{void}, otherwise it is equivalent to

\begin{codeblock}
{
  auto && __expr = cast-expression;
  if ( !await-ready-expr && await-suspend-expr ) {
    suspend-resume-point
  }
  return await-resume-expr;
}
\end{codeblock}

where \tcode{__expr} is a variable defined for
exposition only, and \tcode{_ExprT} is the type of the
\grammarterm{}{cast-expression}, and \tcode{_CoroutineHandle}
is an object of the \tcode{coroutine_handle} type specialized for an enclosing function,
and \textit{await-ready-expr}, \textit{await-suspend-expr} and \textit{await-expr} are
determined as follows:

\begin{itemize}
	\item if \tcode{_ExprT} is a class type, the \grammarterm{unqualified-id}{s}
	\tcode{await_ready}, \tcode{await_suspend} and \tcode{await_resume} are 
	looked up in the scope of class \tcode{\mbox{_ExprT}}
	as if by class member access lookup~(\cxxref{basic.lookup.classref}), and if it finds at least one declaration, 
	\tcode{await_ready}, \tcode{await_suspend} and \tcode{await_resume} are
	\tcode{__expr.await_ready()}, \tcode{__expr.await_suspend(_CoroutineHandle)} and \tcode{__expr.await_resume()},
	respectively;
	
	\item otherwise, \textit{await_ready}, \textit{await_suspend} and \textit{await_resume} are 
	\tcode{await_ready(__expr)}, \tcode{await_resume(__expr, _CoroutineHandle)} and \tcode{await_resume(__expr)} 
	respectively, where 
	\tcode{await_ready}, \tcode{await_suspend} and \tcode{await_resume} are 
	looked up up in the associated namespaces~(\cxxref{basic.lookup.argdep}).
	\enternote Ordinary unqualified lookup~(\cxxref{basic.lookup.unqual}) is not
	performed. \exitnote
\end{itemize}

\enterexample
\begin{codeblock}
	int result = await async([]{return 5;})
\end{codeblock}
\exitexample%

\pnum
 
\enterexample
\begin{codeblock}	
future<int> f() noexcept;
	
int main() {
  using t = decltype(await f()); // t is int
  static_assert(sizeof(await f()) == sizeof(int));
  cout << typeid(await f()).name() << endl;
  cout << noexcept(await f()) << endl;
}
\end{codeblock}
\exitexample%
 