
\rSec0[stmt.stmt]{Statements}%

\setcounter{section}{4}
\rSec1[stmt.iter]{Iteration statements}%
Add underlined text to paragraph 1.
%NOTE: change the grammar

\begin{quote}
\pnum
Iteration statements specify looping.

\indextext{statement!\idxcode{while}}%
\indextext{statement!\idxcode{do}}%
\indextext{statement!\idxcode{for}}%
%
\begin{bnf}
	\nontermdef{iteration-statement}\br
	\terminal{while (} condition \terminal{)} statement\br
	\terminal{do} statement \terminal{while (} expression \terminal{) ;}\br
	\terminal{for (} for-init-statement condition\opt \terminal{;} expression\opt \terminal{)} statement\br
	\terminal{for (} for-range-declaration \terminal{:} for-range-initializer \terminal{)} statement\br
	\added{\terminal{cofor (} for-range-declaration \terminal{:} for-range-initializer \terminal{)} statement}
\end{bnf}
\end{quote}

% goes inside and need fixing goes after

\setcounter{subsection}{4}
\rSec2[stmt.for.await]{The \tcode{cofor} statement}%

Add this section to \ref{stmt.iter}.


\begin{quote}
\pnum
A \tcode{cofor} statement of the form

\begin{ncbnf}
	\terminal{cofor (} for-range-declaration : expression \terminal{)} statement
\end{ncbnf}
is equivalent to

\begin{codeblock}
	{
		auto && __range = range-init;
		for ( auto __begin = coawait begin-expr,
		__end = end-expr;
		__begin != __end;
		coawait ++__begin ) {
			@\textit{for-range-declaration}@ = *__begin;
			@\textit{statement}@
		}
	}
\end{codeblock}

where \tcode{__range}, \tcode{__begin}, 
\textit{range-init}, \textit{begin-expr}, and \textit{end-expr} are defined as in the range-based \tcode{for} statement (\cxxref{stmt.ranged}).

\end{quote}

\setcounter{section}{5}
\rSec1[stmt.jump]{Jump statements}%

% Fix some
In paragraph 1 add four productions to the grammar:

\begin{quote}
\begin{bnf}
	\nontermdef{jump-statement}\br
	\terminal{break ;}\br
	\terminal{continue ;}\br
	\terminal{return} expression\opt \terminal{;}\br
	\terminal{return} braced-init-list \terminal{;}\br
	\added{\terminal{coreturn} expression\opt \terminal{;}}\br
  \added{\terminal{coreturn} braced-init-list \terminal{;}}\br
  \added{\terminal{coyield} expression \terminal{;}}\br
	\added{\terminal{coyield} braced-init-list \terminal{;}}\br
	\terminal{goto} identifier \terminal{;}
\end{bnf}
\end{quote}

\setcounter{subsection}{2}
\rSec2[stmt.return]{The \tcode{return} statement}%
\indextext{\idxcode{return}}%
\indextext{function~return|see{\tcode{return}}}%

% A
Modify paragraph 1 to read:

\begin{quote}
\pnum
A function returns to its caller by the return statement. \added{Using a \tcode{return} statement in the coroutine makes the program ill-formed.}
\end{quote}

%NOTE

%Add a note:
%
%\begin{quote}
%\enternote
%In this section a function refers to non-coroutines only.
%The return statement in coroutines is described in \ref{stmt.return.coroutine}
%\exitnote
%\end{quote}

%Modify paragraphs 1 through 3 as follows.
%
%\begin{quote}
%\pnum
%A function returns to its caller by the \tcode{return} statement.
%\added{A coroutine also returns to its caller 
%when suspended at suspend-resume point.}
%
%\pnum
%\added{In a non-coroutine a}\removed{A} return statement
%with neither an \grammarterm{expression} nor a \grammarterm{braced-init-list}
%can be used only in functions
%that do not return a value, that is, a function with the return type
%\cv\ \tcode{void}, a constructor~(\cxxref{class.ctor}), or a
%destructor~(\cxxref{class.dtor}).
%\indextext{\idxcode{return}!constructor~and}%
%\indextext{\idxcode{return}!constructor~and}%
%\added{In a coroutine a  return statement
%	with neither an \grammarterm{expression} nor a \grammarterm{braced-init-list}
%	can be used only in functions
%	with eventual return type \tcode{void}.}
%A return statement with an expression of non-void type can be used only
%in \added{non-coroutine} functions returning a value
%\added{or coroutines returning an eventual value}; the value of the expression is returned
%to the caller of the function.
%\indextext{conversion!return~type}%
%The value of the expression is implicitly converted to the return type of the
%function in which it appears. A return statement can involve the
%construction and copy or move of a temporary object~(\cxxref{class.temporary}).
%\enternote
%A copy or move operation associated with a return statement may be elided or
%considered as an rvalue for the purpose of overload resolution in
%selecting a constructor~(\cxxref{class.copy}).
%\exitnote A return statement with a \grammarterm{braced-init-list} initializes the object or reference to be returned from the function by copy-list-initialization~(\cxxref{dcl.init.list}) from the specified initializer list. \enterexample
%
%\begin{codeblock}
%	std::pair<std::string,int> f(const char* p, int x) {
%		return {p,x};
%	}
%\end{codeblock}
%\exitexample
%
%Flowing off the end of a function is equivalent to a \tcode{return} with
%no value; this results in undefined behavior in a value-returning
%\added{non-coroutine} function \added{or in an eventual-value-returning coroutine}.
%
%\pnum
%A return statement with an expression of type \tcode{void}
%can be used only in \added{non-coroutine} functions with a return type of
%\cvqual{cv} \tcode{void} \added{or coroutines with eventual return type of \tcode{void}}; 
%the expression is evaluated just before the function
%returns to its caller.
%\end{quote}
%
%%Add underlined text to paragraph 1:
%%\pnum
%%A function returns to its caller by the \tcode{return} statement
%%\added{or by reaching suspend-resume-point}.
%
%Add paragraph 4.
%
%\begin{quote}
%\setcounter{Paras}{3}
%\pnum 
%In a coroutine return statement is replaced with
%a call to __pr.set_result, where _p
%\end{quote}

\rSec2[stmt.return.coroutine]{The \tcode{coreturn} statement}%

Add this section to \ref{stmt.jump}.

\begin{quote}
%\enternote
%In this section function refers to coroutine only.
%The return statement in non-coroutines is described in \ref{stmt.return}
%\exitnote

\pnum
A coroutine returns to its caller by the \tcode{coreturn} statement
or when suspended at a suspend-resume point (\ref{dcl.fct.def.coroutine}). A \tcode{coreturn} statement shall not appear in a function other than a coroutine.

% NOTES: Italic lowercase p

\pnum
  In this section, \textit{p} refers to the promise object  
  (\ref{dcl.fct.def.coroutine})
  of the enclosing coroutine.
  
\pnum
  If the promise type (\ref{dcl.fct.def.coroutine}) of the coroutine defines the member function \tcode{return_void}, the coroutine is considered to have an \term{eventual return type} of \tcode{void}, otherwise, if the promise type (\ref{dcl.fct.def.coroutine}) of the coroutine defines the member function \tcode{return_value}, the coroutine is considered to have an eventual return value of non-\tcode{void} type, otherwise, the coroutine is not considered to have an eventual return type.
  
\pnum
A \tcode{coreturn} statement
with neither an \grammarterm{expression} nor a \grammarterm{braced-init-list}
can be used only in coroutines
that do not have an eventual return type or have an eventual return type of \tcode{void}. In the latter case, completion of the coroutine
is signaled to the promise of the coroutine by calling \tcode{\textit{p}.return_void()}.
A \tcode{coreturn} statement with an expression of non-\tcode{void} type can be used only
in coroutines producing an eventual value; the value of the expression is supplied to the promise of the coroutine by calling 
\tcode{\textit{p}.return_value(\grammarterm{expression})} or
\tcode{\textit{p}.return_value(\grammarterm{braced-init-list})}.

\enterexample

\begin{codeblock}
  std::future<std::pair<std::string,int>> f(const char* p, int x) {
    coawait g();
    coreturn {p,x};
  }
\end{codeblock}
\exitexample

Flowing off the end of a coroutine is equivalent to a \tcode{coreturn} with
no operand; 

% NOTE: Parallel to return
%in an eventual-value-returning coroutine.
\enternote
One possible implementation is to call std::terminate() in this case.
\exitnote

\pnum
A \tcode{coreturn} statement with an expression of type \textit{cv-void}
can be used only in functions without an eventual return type 
or with an eventual return type of \tcode{void}; the expression is evaluated just before the call to \tcode{_Pr.return_void()}.

% NOTE: check the core issue list

\pnum
Prior to returning to the caller, a coroutine evaluates
the \tcode{_Pr.final_suspend()} predicate. If \tcode{_Pr.final_suspend()} contextually converted to \tcode{bool} evaluates to
\tcode{true}, the coroutine suspends at \term{final suspend point} (\ref{dcl.fct.def.coroutine}),
otherwise, the coroutine flows off the end of the function-body and destroys the \term{coroutine state} and frees the memory dynamically allocated (if any) to store the state.

% this is fishy ^^^^ 

%\enternote
%If coroutine instance lifetime is controlled 
%by a RAII object, it is expected that \tcode{_Pr.final_suspend()} returns true
%and coroutine state will be destroyed when
%destructor of an owner object runs.
%
%For detached tasks, where lifetime of the coroutine ends
%when the task completes, \tcode{_Pr.final_suspend()} would return false.
%\exitnote

\end{quote}

\rSec2[stmt.yield]{The \tcode{coyield} statement}%

Add this section to \ref{stmt.jump}.

\begin{quote}

Let \textit{yielded value} be the operand of the \tcode{coyield} statement. A \tcode{coyield} statement is equivalent to 

%... stuff

\pnum
For a \tcode{coyield} statement of the form

\begin{codeblock}
  coyield @\textit{expression}@;
\end{codeblock}

let \textit{yielded-value} be equivalent to the \grammarterm{expression} surrounded
by parentheses

% d

\begin{ncbnf}
  expression
\end{ncbnf}

and for a \tcode{yield} statement of the form

\begin{codeblock}
  coyield @\textit{braced-init-list}@;
\end{codeblock}

let \textit{yielded-value} be equivalent to the \grammarterm{braced-init-list}. In each case,
a \tcode{coyield} statement is equivalent to

\begin{codeblock}
  _Pr.yield_value(@\textit{yielded-value}@);
  @\textit{suspend-resume-point}
\end{codeblock}

If a \tcode{_Pr.yield_value(\textit{yielded-value})} expression is of type \tcode{void}, otherwise it is equivalent to:

\begin{codeblock}
  if (_Pr.yield_value(@\textit{yielded-value}@)) {
    @\textit{suspend-resume-point}@
  }
\end{codeblock}

Where \tcode{_Pr} is a \term{promise object} (\ref{dcl.fct.def.coroutine}) of the enclosing coroutine.

%\pnum
%A \tcode{coyield} statement may only appear if a \tcode{yield_value} member
%function is defined in the promise type of the enclosing coroutine.

%NOTE: not pretty, can we remove the duplication
%NOTE: make if first

\pnum
\enternote
A promise object may have more than one overload of a \tcode{yield_value}.

\enterexample
\begin{codeblock}
  recursive_generator<int> flatten(node* n)
  {
    if (n == nullptr)
      coreturn;
    
    coyield flatten(n->left);
    coyield n->value;
    coyield flatten(n->right);
  }
\end{codeblock}

The promise for the \tcode{flatten} function should contain overloads that can accept a value of type \tcode{int} and a value of type \tcode{recursive_generator<int>}.
In the former case, yielding a value is unconditional. In the latter case, the nested generator may produce an empty sequence of values and thus suspension at the yield point no yielding occurs and  \tcode{yield_value} should return \tcode{false}. 
\exitexample
\exitnote

\end{quote}