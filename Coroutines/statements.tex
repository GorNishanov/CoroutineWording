
\rSec0[stmt.stmt]{Statements}%

\setcounter{section}{4}
\rSec1[stmt.iter]{Iteration statements}%
Add underlined text to paragraph 1.
%NOTE: change the grammar

\begin{quote}
\pnum
Iteration statements specify looping.

\indextext{statement!\idxcode{while}}%
\indextext{statement!\idxcode{do}}%
\indextext{statement!\idxcode{for}}%
%
\begin{bnf}
	\nontermdef{iteration-statement}\br
	\terminal{while (} condition \terminal{)} statement\br
	\terminal{do} statement \terminal{while (} expression \terminal{) ;}\br
	\terminal{for (} for-init-statement condition\opt \terminal{;} expression\opt \terminal{)} statement\br
	\terminal{for} \added{\terminal{await-keyword}\opt} \terminal{(} for-range-declaration \terminal{:} for-range-initializer \terminal{)} statement\br
%	\added{\terminal{cofor (} for-range-declaration \terminal{:} for-range-initializer \terminal{)} statement}
\end{bnf}
\end{quote}

% goes inside and need fixing goes after

\setcounter{subsection}{3}
\rSec2[stmt.ranged]{The range-based \tcode{for} statement}%
\indextext{statement!range~based \idxcode{for}}

Add the underlined text to paragraph 1.

\begin{quote}
\pnum
For a range-based \tcode{for} statement of the form

\begin{ncbnf}
  \terminal{for}  \added{\terminal{await-keyword}\opt} \terminal{(} for-range-declaration : expression \terminal{)} statement
\end{ncbnf}

let \textit{range-init} be equivalent to the \grammarterm{expression} surrounded
by parentheses\footnote{this ensures that a top-level comma operator cannot be
  reinterpreted as a delimiter between \grammarterm{init-declarator}{s} in the
  declaration of \tcode{__range}.}

\begin{ncbnf}
  \terminal{(} expression \terminal{)}
\end{ncbnf}

and for a range-based \tcode{for} statement of the form

\begin{ncbnf}
  \terminal{for} \added{\terminal{await-keyword}\opt} \terminal{(} for-range-declaration \terminal{:} braced-init-list \terminal{)} statement
\end{ncbnf}

let \textit{range-init} be equivalent to the \grammarterm{braced-init-list}. In each case, a
range-based \tcode{for} statement
is equivalent to

\begin{codeblock}
  {
    auto && __range = range-init;
    for ( auto __begin =  @\added{\tcode{await-keyword}\opt}@ begin-expr,
    __end = end-expr;
    __begin != __end;
     @\added{\tcode{await-keyword}\opt}@ ++__begin ) {
      @\textit{for-range-declaration}@ = *__begin;
      @\textit{statement}@
    }
  }
\end{codeblock}

where 
\added{\tcode{await-keyword} appears if and only if it appears immediately after the \tcode{for} keyword, and}\linebreak
\tcode{__range}, \tcode{__begin}, and \tcode{__end} are variables defined for
exposition only, and \tcode{_RangeT} is the type of the
\grammarterm{}{expression}, and \textit{begin-expr} and \textit{end-expr} are
determined as follows: ...

%\ednote{The remainder of paragraph 1 remains unchanged and is not included here.}

\end{quote}

%\setcounter{subsection}{4}
%\rSec2[stmt.for.await]{The \tcode{cofor} statement}%
%
%Add this section to \ref{stmt.iter}.
%
%
%\begin{quote}
%\pnum
%A \tcode{cofor} statement of the form
%
%\begin{ncbnf}
%	\terminal{cofor (} for-range-declaration : expression \terminal{)} statement
%\end{ncbnf}
%is equivalent to
%
%\begin{codeblock}
%	{
%		auto && __range = range-init;
%		for ( auto __begin = await-keyword begin-expr,
%		__end = end-expr;
%		__begin != __end;
%		await-keyword ++__begin ) {
%			@\textit{for-range-declaration}@ = *__begin;
%			@\textit{statement}@
%		}
%	}
%\end{codeblock}
%
%where \tcode{__range}, \tcode{__begin}, \tcode{__end}, 
%\textit{range-init}, \textit{begin-expr}, and \textit{end-expr} are defined as in the range-based \tcode{for} statement (\cxxref{stmt.ranged}).
%
%\end{quote}

\setcounter{section}{5}
\rSec1[stmt.jump]{Jump statements}%

\setcounter{subsection}{2}
\rSec2[stmt.return]{The \tcode{return} statement}%
\indextext{\idxcode{return}}%
\indextext{function~return|see{\tcode{return}}}%

% A
Add underlined text to paragraph 1:

\begin{quote}
\pnum
A function returns to its caller by the \tcode{return} statement.
\added{In this section, function refers to a function that is not a coroutine. The \tcode{return} statement in a coroutine described in section \ref{stmt.return.coroutine}.}
% \added{A \tcode{return} statement shall not appear in a coroutine.}
%\added{Using a \tcode{return} statement in a coroutine makes the program ill-formed.}
\end{quote}

%NOTE

%Add a note:
%
%\begin{quote}
%\enternote
%In this section a function refers to non-coroutines only.
%The return statement in coroutines is described in \ref{stmt.return.coroutine}
%\exitnote
%\end{quote}

%Modify paragraphs 1 through 3 as follows.
%
%\begin{quote}
%\pnum
%A function returns to its caller by the \tcode{return} statement.
%\added{A coroutine also returns to its caller 
%when suspended at suspend-resume point.}
%
%\pnum
%\added{In a non-coroutine a}\removed{A} return statement
%with neither an \grammarterm{expression} nor a \grammarterm{braced-init-list}
%can be used only in functions
%that do not return a value, that is, a function with the return type
%\cv\ \tcode{void}, a constructor~(\cxxref{class.ctor}), or a
%destructor~(\cxxref{class.dtor}).
%\indextext{\idxcode{return}!constructor~and}%
%\indextext{\idxcode{return}!constructor~and}%
%\added{In a coroutine a  return statement
%	with neither an \grammarterm{expression} nor a \grammarterm{braced-init-list}
%	can be used only in functions
%	with eventual return type \tcode{void}.}
%A return statement with an expression of non-void type can be used only
%in \added{non-coroutine} functions returning a value
%\added{or coroutines returning an eventual value}; the value of the expression is returned
%to the caller of the function.
%\indextext{conversion!return~type}%
%The value of the expression is implicitly converted to the return type of the
%function in which it appears. A return statement can involve the
%construction and copy or move of a temporary object~(\cxxref{class.temporary}).
%\enternote
%A copy or move operation associated with a return statement may be elided or
%considered as an rvalue for the purpose of overload resolution in
%selecting a constructor~(\cxxref{class.copy}).
%\exitnote A return statement with a \grammarterm{braced-init-list} initializes the object or reference to be returned from the function by copy-list-initialization~(\cxxref{dcl.init.list}) from the specified initializer list. \enterexample
%
%\begin{codeblock}
%	std::pair<std::string,int> f(const char* p, int x) {
%		return {p,x};
%	}
%\end{codeblock}
%\exitexample
%
%Flowing off the end of a function is equivalent to a \tcode{return} with
%no value; this results in undefined behavior in a value-returning
%\added{non-coroutine} function \added{or in an eventual-value-returning coroutine}.
%
%\pnum
%A return statement with an expression of type \tcode{void}
%can be used only in \added{non-coroutine} functions with a return type of
%\cvqual{cv} \tcode{void} \added{or coroutines with eventual return type of \tcode{void}}; 
%the expression is evaluated just before the function
%returns to its caller.
%\end{quote}
%
%%Add underlined text to paragraph 1:
%%\pnum
%%A function returns to its caller by the \tcode{return} statement
%%\added{or by reaching suspend-resume-point}.
%
%Add paragraph 4.
%
%\begin{quote}
%\setcounter{Paras}{3}
%\pnum 
%In a coroutine return statement is replaced with
%a call to __pr.set_result, where _p
%\end{quote}

\rSec3[stmt.return.coroutine]{The \tcode{return} statement in a coroutine}%

Add this section to \ref{stmt.jump}.

\begin{quote}
%\enternote
%In this section function refers to coroutine only.
%The return statement in non-coroutines is described in \ref{stmt.return}
%\exitnote

\pnum
A coroutine returns to its caller by the \tcode{return} statement
or when suspended at a suspend-resume point (\ref{dcl.fct.def.coroutine}). 

\pnum
  If the promise type (\ref{dcl.fct.def.coroutine}) of the coroutine defines the member function \tcode{return_void}, the coroutine is considered to have an \term{eventual return type} of \tcode{void}, if the promise type (\ref{dcl.fct.def.coroutine}) of the coroutine defines the member function \tcode{return_value}, the coroutine is considered to have a non-\tcode{void} eventual return  type, otherwise, the coroutine is considered not to have an eventual return type. If the promise type defines both \tcode{return_value} and \tcode{return_void} member functions, the program is ill-formed.

\pnum
In this section, \textit{p} refers to the promise object  
(\ref{dcl.fct.def.coroutine})
of the enclosing coroutine.

\pnum
A \tcode{return} statement
with no operand shall be used only in coroutines
without an eventual return type or with an eventual return type of \tcode{void}. In the latter case, completion of the coroutine
is signaled to the promise of the coroutine by calling \tcode{\textit{p}.return_void()}.

\pnum
A \tcode{return} statement with an operand of type \tcode{void} shall be used only in functions without an eventual return type 
or with an eventual return type of \tcode{void}; in the former case, the operand is evaluated just before the call to \tcode{\textit{p}.final_suspend()}  (\ref{dcl.fct.def.coroutine}); in the later case, the completion of the coroutine is signaled to the promise of the coroutine by calling \tcode{p.return_void()} and the operand is evaluated just prior to the call to \tcode{\textit{p}.return_void()}. 

\pnum
A \tcode{return} statement with any other operand shall be used only
in coroutines producing an eventual value; the completion of the coroutine is signalled to the promise by calling \linebreak 
\tcode{\textit{p}.return_value(\textit{operand})}.
Flowing off the end of a coroutine is equivalent to a \tcode{return} with no value; this results in undefined behavior in a coroutine with non-\tcode{void} return type.
\enternote
The expression passed to \tcode{return_value} is an xvalue.
\exitnote




% this is fishy ^^^^ 

%\enternote
%If coroutine instance lifetime is controlled 
%by a RAII object, it is expected that \tcode{_Pr.final_suspend()} returns true
%and coroutine state will be destroyed when
%destructor of an owner object runs.
%
%For detached tasks, where lifetime of the coroutine ends
%when the task completes, \tcode{_Pr.final_suspend()} would return false.
%\exitnote

\end{quote}

%\rSec2[stmt.yield]{The \tcode{yield} statement}%
%
%Add this section to \ref{stmt.jump}.
%
%\begin{quote}
%
%Let \textit{yielded value} be the operand of the \tcode{yield-keyword} statement and \textit{p} be the promise object of the enclosing coroutine.
%If the result type of \tcode{\textit{p}.yield_value(\textit{yielded-value})} is of type \cvvoid, then the \tcode{yield-keyword} statement is equivalent to:
%
%\begin{codeblock}
%  @\textit{p}@.yield_value(@\textit{yielded-value}@);
%  @\textit{suspend-resume-point}
%\end{codeblock}
%
%otherwise, it is equivalent to:
%
%\begin{codeblock}
%  if (@\textit{p}@.yield_value(@\textit{yielded-value}@)) {
%    @\textit{suspend-resume-point}@
%  }
%  
%\end{codeblock}

%\pnum
%A \tcode{yield-keyword} statement may only appear if a \tcode{yield_value} member
%function is defined in the promise type of the enclosing coroutine.

%NOTE: not pretty, can we remove the duplication
%NOTE: make if first
%
%\pnum
%\enternote
%A promise object may have more than one overload of a \tcode{yield_value}.
%
%\enterexample
%\begin{codeblock}
%  recursive_generator<int> flatten(node* n)
%  {
%    if (n == nullptr)
%      return;
%    
%    yield-keyword flatten(n->left);
%    yield-keyword n->value;
%    yield-keyword flatten(n->right);
%  }
%\end{codeblock}
%
%The promise for the \tcode{flatten} function should contain overloads that can accept a value of type \tcode{int} and a value of type \tcode{recursive_generator<int>}.
%In the former case, yielding a value is unconditional. In the latter case, the nested generator may produce an empty sequence of values and thus suspension at the yield point no yielding occurs and  \tcode{yield_value} should return \tcode{false}. 
%\exitexample
%\exitnote

%\end{quote}