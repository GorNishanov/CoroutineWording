
\setcounter{chapter}{17}
\rSec0[language.support]{Language support library}

\rSec1[support.general]{General}

Add a row to Table~\ref{tab:lang.sup.lib.summary} for \tcode{<experimental/coroutine>}


\begin{libsumtab}{Language support library summary}{tab:lang.sup.lib.summary}
	\cxxref{support.types}       & Types                     &   \tcode{<cstddef>}   \\ \rowsep
	&                           &   \tcode{<limits>}    \\
	\cxxref{support.limits}      & Implementation properties &   \tcode{<climits>}   \\
	&                           &   \tcode{<cfloat>}    \\ \rowsep
	\cxxref{cstdint}             & Integer types             & \tcode{<cstdint>}     \\ \rowsep
	\cxxref{support.start.term}  & Start and termination     &   \tcode{<cstdlib>}   \\ \rowsep
	\cxxref{support.dynamic}     & Dynamic memory management &   \tcode{<new>}       \\ \rowsep
	\cxxref{support.rtti}        & Type identification       &   \tcode{<typeinfo>}  \\ \rowsep
	\cxxref{support.exception}   & Exception handling        &   \tcode{<exception>} \\ \rowsep
	\cxxref{support.initlist}    & Initializer lists & \tcode{<initializer_list>}    \\ \rowsep
	\added{\ref{support.coroutine}} 
  & \added{Coroutines support} 
  & \added{\tcode{<experimental/coroutine>}}    \\ \rowsep
	&                           &   \tcode{<csignal>}   \\
	&                           &   \tcode{<csetjmp>}   \\
	&                           &   \tcode{<cstdalign>} \\
	\cxxref{support.runtime}     & Other runtime support     &   \tcode{<cstdarg>}   \\
	&                           &   \tcode{<cstdbool>}  \\
	&                           &   \tcode{<cstdlib>}   \\
	&                           &   \tcode{<ctime>}     \\
\end{libsumtab}


\setcounter{section}{9}
\rSec1[support.runtime]{Other runtime support}

Add underlined text to paragraph 4.

\begin{quote}
\setcounter{Paras}{3}
\pnum
The function signature
\indexlibrary{\idxcode{longjmp}}%
\tcode{longjmp(jmp_buf jbuf, int val)}
has more restricted behavior in this International Standard.
A \tcode{setjmp}/\tcode{longjmp} call pair has undefined
behavior if replacing the \tcode{setjmp} and \tcode{longjmp}
by \tcode{catch} and \tcode{throw} would invoke any non-trivial destructors for any automatic
objects.
%
\added{A \tcode{setjmp}/\tcode{longjmp} call pair has undefined
behavior if invoked in a coroutine.}

\xref ISO C~7.10.4, 7.8, 7.6, 7.12.
\end{quote}

\setcounter{section}{10}
\rSec1[support.coroutine]{Coroutines support library}

Add this section to clause \ref{language.support}.

\begin{quote}

\pnum
The header
\tcode{<experimental/coroutine>}
defines several types providing compile and run-time support for coroutines in a \Cpp program.

\synopsis{Header \tcode{<experimental/coroutine>} synopsis}

\indextext{\idxhdr{experimental/coroutine}}%
\indexlibrary{\idxhdr{experimental/coroutine}}%
\begin{codeblock}
namespace std {
namespace experimental {
  // \ref{coroutine.traits} coroutine traits
  template <typename R, typename... ArgTypes>
    class coroutine_traits;
	
  // \ref{coroutine.handle} coroutine handle
  template <typename Promise = void>
    class coroutine_handle;		

  // \ref{coroutine.handle.compare} comparison operators:	
  bool operator==(coroutine_handle<> x, coroutine_handle<> y) noexcept;
  bool operator<(coroutine_handle<> x, coroutine_handle<> y) noexcept;			
  bool operator!=(coroutine_handle<> x, coroutine_handle<> y) noexcept;
  bool operator<=(coroutine_handle<> x, coroutine_handle<> y) noexcept;			
  bool operator>=(coroutine_handle<> x, coroutine_handle<> y) noexcept;
  bool operator>(coroutine_handle<> x, coroutine_handle<> y) noexcept;	  
}
}
namespace std {
  // \ref{coroutine.handle.hash} hash support:
  template <class T> struct hash;
  template <class P> struct hash<experimental::coroutine_handle<P>>;
}
\end{codeblock}

\rSec2[coroutine.traits]{coroutine traits}
\pnum
This subclause defines requirements on classes representing
\term{coroutine traits},
and defines a primary struct template
\tcode{coroutine_traits<R,Args...>}
that satisfies those requirements.

%\pnum
%Coroutines need a set of related types and functions
%to complete the definition of their semantics.
%These types and functions are provided as a set of member types or typedefs
%and functions in the instantiation of struct template
%\tcode{coroutine_traits}. This subclause defines the semantics of these
%members.

\pnum
The \tcode{coroutine_traits} may be specialized by the user 
to customize semantics of coroutines.

\rSec3[coroutine.traits.requirements]{Coroutine traits requirements}
\pnum
In Table~\ref{tab:coroutine.traits.requirements}, X denotes 
a trait class instantiated as described in \ref{dcl.fct.def.coroutine};
$a_1$, $a_2$, ... $a_n$ denote parameters passed to a coroutine. If it is a member function, than $a_1$ denotes implicit \tcode{this} parameter.

\begin{concepttable}{\tcode{coroutine_traits} requirements}{tab:coroutine.traits.requirements}
  {p{1.6in}p{4.15in}}
  \topline
  Expression          &   Behavior \\ \capsep
  \tcode{X::promise_type}     &
  \tcode{X::promise_type} must be a type satisfying coroutine promise requirements (\ref{coroutine.promise}) 
%  that completes the definition of coroutine semantics.
  \\ \rowsep
  \tcode{X::get_allocator($a_1$, $a_2$, ... $a_n$)}        &
  \textit{(optional)} Given a set of arguments passed to a coroutine,
  returns an allocator (\cxxref{allocator.requirements}) that implementation shall use
  to dynamically allocate memory for coroutine state if dynamic allocation is required.
  If \tcode{get_allocator} is not present, 
  implementation shall use \tcode{std::allocator<char>}.
\\ \rowsep
  \tcode{X::get_return_object_on_allocation_failure()}     &
\textit{(optional)} If present, it is assumed that an
allocator's \tcode{allocate} function will violate the standard requirements and return \tcode{nullptr} in case of an
allocation failure. If a coroutine requires dynamic allocation, it must check if an \tcode{allocate} returns nullptr, and if so it shall use the expression \tcode{X::get_return_object_on_allocation_failure()} to construct the return value and return back to the caller.
  \\ 
\end{concepttable}

\rSec3[coroutine.traits.primary]{Struct template \tcode{coroutine_traits}}
\pnum The header \tcode{<coroutine>} shall define
primary struct template \tcode{coroutine_traits} as follows:

%\pnum The requirements for the members are given in clause \ref{coroutine.traits.requirements}.
\indexlibrary{\idxcode{coroutine_traits}}%
\begin{codeblock}
namespace std {
namespace experimental {
  template <typename R, typename... Args>
  struct coroutine_traits {
    using promise_type = typename R::promise_type;
  };
} // namespace experimental
} // namespace std
\end{codeblock}

\rSec2[coroutine.handle]{Struct template \tcode{coroutine_handle}}

\indexlibrary{\idxcode{coroutine_handle}}%
\begin{codeblock}
namespace std {
  namespace experimental {
    template <>
    struct coroutine_handle<void>
    {
      // \ref{coroutine.handle.con} construct/reset
      coroutine_handle() noexcept;		
      coroutine_handle(std::nullptr_t) noexcept;
      coroutine_handle& operator=(nullptr_t) noexcept;
      
      // \ref{coroutine.handle.export} export/import
      static coroutine_handle from_address(void* addr) noexcept;		
      void* to_address() const noexcept;
      
      // \ref{coroutine.handle.capacity} capacity
      explicit operator bool() const noexcept;
      
      // \ref{coroutine.handle.resumption} resumption
      void operator()() const;
      void resume() const;	
      void destroy() const;
      
      // \ref{coroutine.handle.completion} completion check
      bool done() const noexcept; 
    };
    
    template <typename Promise>
    struct coroutine_handle : coroutine_handle<>
    {
      // \ref{coroutine.handle.con} construct/reset
      using coroutine_handle<>::coroutine_handle;
      coroutine_handle(Promise*) noexcept;		
      coroutine_handle& operator=(nullptr_t) noexcept;
      
      // \ref{coroutine.handle.prom} promise access
      Promise& promise() noexcept;		
      Promise const& promise() const noexcept;
    };
  }
}
\end{codeblock}

\pnum
Let \textit{P} be a promise type of the coroutine (\ref{dcl.fct.def.coroutine}). An object of the type \tcode{coroutine_handle<\textit{P}>} is called a \term{coroutine handle}
and can be used to refer to a suspended or executing coroutine.
Such function is called a \textit{target} of a coroutine handle.
A default constructed \tcode{coroutine_handle} object has no target.


\rSec3[coroutine.handle.con]{\tcode{coroutine_handle} construct/reset}
\begin{itemdecl}
  coroutine_handle() noexcept;		
  coroutine_handle(std::nullptr_t) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\postconditions \tcode{!*this}.
\end{itemdescr}

\begin{itemdecl}
  coroutine_handle(Promise* p) noexcept;	
\end{itemdecl}
\begin{itemdescr}
  \pnum
  \precondition \tcode{p} points to a promise object of a coroutine.
  
	\pnum
  \postconditions \tcode{!*this} and \tcode{std::addressof(this->promise()) == p}.
\end{itemdescr}

\begin{itemdecl}
  coroutine_handle& operator=(nullptr_t) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum\postconditions \tcode{!*this}.
  
  \pnum\returns \tcode{*this}.
\end{itemdescr}

\rSec3[coroutine.handle.export]{\tcode{coroutine_handle} export/import}
\begin{itemdecl}
  static coroutine_handle from_address(void* addr) noexcept;		
  void* to_address() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \postconditions \tcode{coroutine_handle<>::from_address(this->to_address()) == *this}.
\end{itemdescr}

\rSec3[coroutine.handle.capacity]{\tcode{coroutine_handle} capacity}
\begin{itemdecl}
  explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns \tcode{true} if \tcode{*this} has a target, otherwise \tcode{false}.
\end{itemdescr}

\rSec3[coroutine.handle.resumption]{\tcode{coroutine_handle} resumption}
\begin{itemdecl}
  void operator()() const;
  void resume() const;	
\end{itemdecl}
\begin{itemdescr}
  \pnum
  \precondition *this refers to a suspended coroutine
  
  \pnum
  \effects resumes the execution of a target function. If the function was suspended
  at the final suspend point, std::terminate is called (\cxxref{except.terminate}).
\end{itemdescr}

\begin{itemdecl}
  void destroy() const;
\end{itemdecl}
\begin{itemdescr}
  \pnum
  \precondition *this refers to a suspended coroutine
  
  \pnum
\end{itemdescr}

\rSec3[coroutine.handle.completion]{\tcode{coroutine_handle} completion check}
\begin{itemdecl}
  bool done() const noexcept; 
\end{itemdecl}
\begin{itemdescr}
  \pnum
  \precondition *this refers to a suspended coroutine
  
  \pnum
  \returns \tcode{true} if the target function is suspended
  at final suspend point, otherwise \tcode{false}.
\end{itemdescr}

\rSec3[coroutine.handle.prom]{\tcode{coroutine_handle} promise access}
\begin{itemdecl}
  Promise& promise() noexcept;		
  Promise const& promise() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \precondition *this refers to a coroutine
  
  \pnum
  \returns a reference to a promise of the target function.
\end{itemdescr}

\rSec3[coroutine.handle.compare]{Comparison operators}

\begin{itemdecl}
  bool operator==(coroutine_handle<> x, coroutine_handle<> y) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns \tcode{x.to_address() == y.to_address()}.
\end{itemdescr}

\begin{itemdecl}
  bool operator<(coroutine_handle<> x, coroutine_handle<> y) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns \tcode{x.to_address() < y.to_address()}.
\end{itemdescr}

\begin{itemdecl}
  bool operator!=(coroutine_handle<> x, coroutine_handle<> y) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns \tcode{!(x == y)}.
\end{itemdescr}

\begin{itemdecl}
  bool operator>(coroutine_handle<> x, coroutine_handle<> y) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns \tcode{(y < x)}.
\end{itemdescr}

\begin{itemdecl}
  bool operator<=(coroutine_handle<> x, coroutine_handle<> y) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns \tcode{!(x > y)}.
\end{itemdescr}

\begin{itemdecl}
  bool operator>=(coroutine_handle<> x, coroutine_handle<> y) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns \tcode{!(x < y)}.
\end{itemdescr}

\rSec3[coroutine.handle.hash]{Hash support}

\begin{itemdecl}
  template <class P> struct hash<experimental::coroutine_handle<P>>;
\end{itemdecl}

\begin{itemdescr}
  \pnum
The template specializations shall meet the requirements of class template hash (\cxxref{unord.hash}).
\end{itemdescr}


\rSec2[coroutine.promise]{Coroutine promise requirements}

\pnum
A user supplies the definition of the coroutine promise to implement 
desired high-level semantics associated with a coroutines
discovered via instantiation of struct template \tcode{coroutine_traits}.
The following tables describe the requirements on
coroutine promise types.

%\pnum
%The template struct \tcode{allocator_traits}~(\ref{allocator.traits}) supplies
%a uniform interface to all allocator types.
%Table~\ref{tab:desc.var.def} describes the types manipulated
%through allocators. Table~\ref{tab:utilities.allocator.requirements}
%describes the requirements on allocator types
%and thus on types used to instantiate \tcode{allocator_traits}. A requirement
%is optional if the last column of
%Table~\ref{tab:utilities.allocator.requirements} specifies a default for a
%given expression. Within the standard library \tcode{allocator_traits}
%template, an optional requirement that is not supplied by an allocator is
%replaced by the specified default expression. A user specialization of
%\tcode{allocator_traits} may provide different defaults and may provide
%defaults for different requirements than the primary template. Within
%Tables~\ref{tab:desc.var.def} and~\ref{tab:utilities.allocator.requirements},
%the use of \tcode{move} and \tcode{forward} always refers to \tcode{std::move}
%and \tcode{std::forward}, respectively.

\begin{libreqtab2}
	{Descriptive variable definitions}
	{tab:desc.var.def}
	\\ \topline
	\lhdr{Variable} &   \rhdr{Definition}   \\  \capsep
	\endfirsthead
	\continuedcaption\\
	\hline
	\lhdr{Variable} &   \rhdr{Definition}   \\  \capsep
	\endhead
	\tcode{P}    &   a coroutine promise type       \\ \rowsep
	\tcode{p}       &   a value of type \tcode{P} \\ \rowsep
	\tcode{e}       &   a value of \tcode{std::exception_ptr} type   \\ \rowsep
	\tcode{h}       &   a value of \tcode{std::experimental::coroutine_handle<P>} type    \\ \rowsep
	\tcode{v}      &   an \grammarterm{expression} or \grammarterm{braced-init-list}   \\ \rowsep
\end{libreqtab2}

\indextext{requirements!\idxcode{CoroutinePromise}}%
\begin{concepttable}{\tcode{CoroutinePromise} requirements}{CoroutinePromise}
	{p{1.6in}p{4.15in}}
	\topline
	Expression          &   Note \\ \capsep
	\tcode{P\{\}}     &   Construct an object of type \tcode{P}\\ \rowsep
	\tcode{p.get_return_object()}        &
The \tcode{get_return_object} is invoked by the coroutine to construct the
return object prior to reaching the first suspend-resume point,
a \tcode{return} statement or flowing off the end of the function.
	\\ \rowsep
	\tcode{p.return_value(v)}     &  
%If present, an enclosing coroutine supports an
%eventual value of a type that \tcode{v} can be converted to. 

Invoked by
a coroutine when 
a \tcode{coroutine-return-keyword} statement
with an \grammarterm{expression} 
or a \grammarterm{braced-init-list}
is encountered in a coroutine (\ref{stmt.coreturn}).
%If a promise type does not satisfy this requirement, the presence of 
%a \tcode{coreturn} statement
%with an \grammarterm{expression} 
%or a \grammarterm{braced-init-list}
%statement in the body results in a compile time error.
	\\ \rowsep
	\tcode{p.return_void()}     &   
%If present, an enclosing coroutine supports an eventual value of type \tcode{void}. 
If present, invoked when 
a \tcode{coroutine-return-keyword} statement is encountered as described in (\ref{stmt.coreturn}).
A promise type shall not define both \mbox{\tcode{return_void}} and \tcode{return_value} member functions.
	\\ \rowsep
	\tcode{p.set_exception(e)} & 
The \tcode{set_exception} is invoked by a coroutine when an
unhandled exception occurs within a \grammarterm{function-body} of the coroutine
function.
If promise does not provide \tcode{set_exception}, an unhandled exception
will propagate from a coroutines normally.
\\ \rowsep
	\tcode{p.yield_value(v)}     &
  The \tcode{yield_value} is invoked
  when \tcode{yield-keyword} statement is
  encountered in the coroutine. If
  promise does not define \tcode{yield_value}, \tcode{yield-keyword}
  statement may not appear in the coroutine body.
	\\ \rowsep
	\tcode{p.initial_suspend()}     &
if \tcode{p.initial_suspend()} evaluates to \tcode{true}, the coroutine will suspend at \textit{initial suspend point} (\ref{dcl.fct.def.coroutine}).
	   \\ \rowsep
	\tcode{p.final_suspend()}     &  
if \tcode{p.final_suspend()} evaluates to \tcode{true}, the coroutine will suspend at \textit{final suspend point} (\ref{dcl.fct.def.coroutine}).
\\ 
\end{concepttable}

\enterexample
This example illustrates full implementation
of a promise type for a simple generator.
\begin{codeblock}
  #include <iostream>
  #include <experimental/coroutine>
  
  struct generator {
    struct promise_type {
      int current_value;
      auto get_return_object() { return generator{this}; }
      auto initial_suspend() { return true; }
      auto final_suspend() { return true; }
      void yield_value(int value) { current_value = value; }
    };
    
    bool move_next() {
      coro.resume();
      return !coro.done();
    }
    
    int current_value() { return coro.promise().current_value; }
    
    ~generator() { coro.destroy(); }
  private:
    explicit generator(promise_type* myPromise) : coro(myPromise) 
    {
    }
    std::experimental::coroutine_handle<promise_type> coro;
  };
  
  generator f() {
    yield-keyword 1;
    yield-keyword 2;
  } 
  
  int main() {
    auto g = f();
    while (g.move_next()) std::cout << g.current_value() << std::endl;
  }
  
\end{codeblock}
\exitexample

\end{quote}
