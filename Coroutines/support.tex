
\setcounter{chapter}{17}
\rSec0[language.support]{Language support library}

\rSec1[support.general]{General}

Add a row to Table~\ref{tab:lang.sup.lib.summary} for \tcode{<experimental/resumable>}


\begin{libsumtab}{Language support library summary}{tab:lang.sup.lib.summary}
	\cxxref{support.types}       & Types                     &   \tcode{<cstddef>}   \\ \rowsep
	&                           &   \tcode{<limits>}    \\
	\cxxref{support.limits}      & Implementation properties &   \tcode{<climits>}   \\
	&                           &   \tcode{<cfloat>}    \\ \rowsep
	\cxxref{cstdint}             & Integer types             & \tcode{<cstdint>}     \\ \rowsep
	\cxxref{support.start.term}  & Start and termination     &   \tcode{<cstdlib>}   \\ \rowsep
	\cxxref{support.dynamic}     & Dynamic memory management &   \tcode{<new>}       \\ \rowsep
	\cxxref{support.rtti}        & Type identification       &   \tcode{<typeinfo>}  \\ \rowsep
	\cxxref{support.exception}   & Exception handling        &   \tcode{<exception>} \\ \rowsep
	\cxxref{support.initlist}    & Initializer lists & \tcode{<initializer_list>}    \\ \rowsep
	\added{\ref{support.resumable}} 
  & \added{Resumable functions support} 
  & \added{\tcode{<experimental/resumable>}}    \\ \rowsep
	&                           &   \tcode{<csignal>}   \\
	&                           &   \tcode{<csetjmp>}   \\
	&                           &   \tcode{<cstdalign>} \\
	\cxxref{support.runtime}     & Other runtime support     &   \tcode{<cstdarg>}   \\
	&                           &   \tcode{<cstdbool>}  \\
	&                           &   \tcode{<cstdlib>}   \\
	&                           &   \tcode{<ctime>}     \\
\end{libsumtab}


Add section \ref{support.resumable}

\setcounter{section}{10}
\rSec1[support.resumable]{Resumable functions support library}

\pnum
The header
\tcode{<experimental/resumable]>}
defines several types supporting resumable functions in a \Cpp program.

\synopsis{Header \tcode{<experimental/resumable>} synopsis}

\indextext{\idxhdr{experimental/resumable}}%
\indexlibrary{\idxhdr{experimental/resumable}}%
\begin{codeblock}
namespace std {
namespace experimental {
  // \ref{resumable.traits} resumable traits
  template <typename R, typename... ArgTypes>
    class resumable_traits;
	
  // \ref{resumable.handle} resumable handle
  template <typename Promise = void>
    class resumable_handle;		
	
  bool operator == (resumable_handle<> x, resumable_handle<> y) noexcept;
  bool operator < (resumable_handle<> x, resumable_handle<> y) noexcept;			
  bool operator != (resumable_handle<> x, resumable_handle<> y) noexcept;
  bool operator <= (resumable_handle<> x, resumable_handle<> y) noexcept;			
  bool operator >= (resumable_handle<> x, resumable_handle<> y) noexcept;
  bool operator > (resumable_handle<> x, resumable_handle<> y) noexcept;			
}
}
\end{codeblock}

\rSec2[resumable.traits]{Class template \tcode{resumable_traits}}

\indexlibrary{\idxcode{resumable_traits}}%
\begin{codeblock}
namespace std {
namespace experimental {
  template <typename R, typename... Ts>
  class resumable_traits {
  public:
    template <typename... Us>
      static auto get_allocator(Us&&...); // optional
			
    static auto get_return_object_on_allocation_failure() noexcept; // optional
			
    using promise_type = typename R::promise_type;
  };
} // namespace experimental
} // namespace std
\end{codeblock}

\pnum
The struct template  
\tcode{resumable_traits}
defines ... .
A default constructed \tcode{resumable_handle} object has no target 
resumable instance object.

provides bla-bla as specified in~\ref{dcl.fct.def.resumable}.
class for the types of objects thrown as exceptions by
\Cpp standard library components, and certain
expressions, to report errors detected during program execution.

\pnum
The \tcode{resumable_traits} may be specialized for user-defined types 
to customize an allocation policy and a promise type for resumable functions.


\rSec2[resumable.handle]{Struct template \tcode{resumable_handle}}

\indexlibrary{\idxcode{resumable_handle}}%
\begin{codeblock}
namespace std {
  namespace experimental {
    template <>
    struct resumable_handle<void>
    {
      // \ref{resumable.handle.con} construct/reset
      resumable_handle() noexcept;		
      resumable_handle(std::nullptr_t) noexcept;
      resumable_handle& operator=(nullptr_t) noexcept;
      
      // \ref{resumable.handle.export} export/import
      static resumable_handle from_address(void* addr) noexcept;		
      void* to_address() const noexcept;
      
      // \ref{resumable.handle.capacity} capacity
      explicit operator bool() const noexcept;
      
      // \ref{resumable.handle.resumption} resumption
      void operator()() const;
      void resume() const;	
      void destroy() const;
      
      // \ref{resumable.handle.completion} completion check
      bool done() const noexcept; 
    };
    
    template <typename Promise>
    struct resumable_handle : resumable_handle<>
    {
      // \ref{resumable.handle.con} construct/reset
      using resumable_handle<>::resumable_handle;
      resumable_handle& operator=(nullptr_t) noexcept;
      
      // \ref{resumable.handle.prom} construct/reset
      static resumable_handle from_promise(Promise*) noexcept;		
      Promise& promise() noexcept;		
      Promise const& promise() const noexcept;
    };
  }
}
\end{codeblock}

\pnum
The struct template \tcode{resumable_handle}
can be used to refer to suspended or executing resumable function.
A default constructed \tcode{resumable_handle} object has no target 
resumable instance object.


\rSec3[resumable.handle.con]{\tcode{resumable_handle} construct/reset}
\begin{itemdecl}
      resumable_handle() noexcept;		
      resumable_handle(std::nullptr_t) noexcept;
      resumable_handle& operator=(nullptr_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
	\pnum\postconditions \tcode{!*this}.
\end{itemdescr}

\rSec3[resumable.handle.export]{\tcode{resumable_handle} export/import}
\begin{itemdecl}
	static resumable_handle from_address(void* addr) noexcept;		
	void* to_address() const noexcept;
\end{itemdecl}

\rSec3[resumable.handle.capacity]{\tcode{resumable_handle} capacity}
\begin{itemdecl}
	explicit operator bool() const noexcept;
\end{itemdecl}

\rSec3[resumable.handle.resumption]{\tcode{resumable_handle} resumption}
\begin{itemdecl}
	void operator()() const;
	void resume() const;	
	void destroy() const;
\end{itemdecl}

\rSec3[resumable.handle.completion]{\tcode{resumable_handle} completion check}
\begin{itemdecl}
	bool done() const noexcept; 
\end{itemdecl}

\rSec3[resumable.handle.prom]{\tcode{resumable_handle} to/from promise}
\begin{itemdecl}
	static resumable_handle from_promise(Promise*) noexcept;		
	Promise& promise() noexcept;		
	Promise const& promise() const noexcept;
\end{itemdecl}

\pnum
The class
\tcode{resumable_traits}
defines the base
class for the types of objects thrown as exceptions by
\Cpp standard library components, and certain
expressions, to report errors detected during program execution.


\rSec2[resumable.promise]{Coroutine promise requirements}

\pnum
A user supplies the definition of the resumable promise to implement 
desired high-level semantics associated with a resumable functions
discovered via specialization of \tcode{resumable_traits}.
The following tables describe the requirements on
coroutine promise types.

%\pnum
%The template struct \tcode{allocator_traits}~(\ref{allocator.traits}) supplies
%a uniform interface to all allocator types.
%Table~\ref{tab:desc.var.def} describes the types manipulated
%through allocators. Table~\ref{tab:utilities.allocator.requirements}
%describes the requirements on allocator types
%and thus on types used to instantiate \tcode{allocator_traits}. A requirement
%is optional if the last column of
%Table~\ref{tab:utilities.allocator.requirements} specifies a default for a
%given expression. Within the standard library \tcode{allocator_traits}
%template, an optional requirement that is not supplied by an allocator is
%replaced by the specified default expression. A user specialization of
%\tcode{allocator_traits} may provide different defaults and may provide
%defaults for different requirements than the primary template. Within
%Tables~\ref{tab:desc.var.def} and~\ref{tab:utilities.allocator.requirements},
%the use of \tcode{move} and \tcode{forward} always refers to \tcode{std::move}
%and \tcode{std::forward}, respectively.

\begin{libreqtab2}
	{Descriptive variable definitions}
	{tab:desc.var.def}
	\\ \topline
	\lhdr{Variable} &   \rhdr{Definition}   \\  \capsep
	\endfirsthead
	\continuedcaption\\
	\hline
	\lhdr{Variable} &   \rhdr{Definition}   \\  \capsep
	\endhead
	\tcode{P}    &   a coroutine promise type       \\ \rowsep
	\tcode{p}       &   a value of type \tcode{P} \\ \rowsep
	\tcode{e}       &   a value of \tcode{std::exception_ptr} type   \\ \rowsep
	\tcode{h}       &   a value of \tcode{std::experimental::resumable_handle<P>} type    \\ \rowsep
	\tcode{T}      &   an arbitrary type    \\ \rowsep
	\tcode{v}      &   a value of type \tcode{T}    \\ \rowsep
\end{libreqtab2}

\indextext{requirements!\idxcode{ResumablePromise}}%
\begin{concepttable}{\tcode{ResumablePromise} requirements}{ResumablePromise}
	{p{1.6in}p{4.15in}}
	\topline
	Expression          &   Note \\ \capsep
	\tcode{P\{\}}     &   Construct an object of type \tcode{P}\\ \rowsep
	\tcode{p.get_return_object()}        &
\tcode{get_return_object} is invoked by the resumable function to construct the
return object prior to reaching the first suspend-resume point.
	\\ \rowsep
	\tcode{p.set_result(v)}     &  
Must be present if enclosing resumable function supports
eventual value of type that \tcode{v} can be converted to. 
Sets the value associated with the promise. \tcode{set_result} is invoked by
a resumable function when 
a return statement
with an \grammarterm{expression} 
or a \grammarterm{braced-init-list}
is encountered in a resumable function.

If a promise type does not satisfy this requirement, presence of 
a return statement
with an \grammarterm{expression} 
or a \grammarterm{braced-init-list}
statement in the body result in a compile time error.
	\\ \rowsep
	\tcode{p.set_result()}     &   
Must be present if enclosing resumable function supports
eventual value of type \tcode{void}. Sets the value associated with the promise. \tcode{set_result} is invoked by
a resumable function when 
a return statement
without an \grammarterm{expression} 
nor a \grammarterm{braced-init-list}
is encountered in a resumable function.
Promise must contain at most one declaration of \tcode{set_result}.
	\\ \rowsep
	\tcode{p.set_exception(e)} & 
\tcode{set_exception} is invoked by a resumable function when an
unhandled exception occurs within a \grammarterm{function-body} of the resumable
function.
If promise does not provide set_exception, an unhandled exception
will propagate from a resumable functions normally.
\\ \rowsep
	\tcode{p.yield_value(v)}     &   
Must be present for enclosing resumable function to support \tcode{yield} statement.
	\\ \rowsep
	\tcode{p.initial_suspend()}     &
if \tcode{p.initial_suspend()} is evaluates to true, resumable function will suspend at initial suspend point prior to entering \grammarterm{function-body}.
	   \\ \rowsep
	\tcode{p.final_suspend()}     &   Construct an object of type \tcode{P}\\ 
\end{concepttable}

\footnotetext{It is intended that \tcode{a.allocate} be an efficient means
	of allocating a single object of type \tcode{T}, even when \tcode{sizeof(T)}
	is small. That is, there is no need for a container to maintain its own
	free list.}
