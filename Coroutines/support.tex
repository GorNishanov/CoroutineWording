
\setcounter{chapter}{17}
\rSec0[language.support]{Language support library}

\rSec1[support.general]{General}

Add a row to Table~\ref{tab:lang.sup.lib.summary} for \tcode{<experimental/resumable>}


\begin{libsumtab}{Language support library summary}{tab:lang.sup.lib.summary}
	\cxxref{support.types}       & Types                     &   \tcode{<cstddef>}   \\ \rowsep
	&                           &   \tcode{<limits>}    \\
	\cxxref{support.limits}      & Implementation properties &   \tcode{<climits>}   \\
	&                           &   \tcode{<cfloat>}    \\ \rowsep
	\cxxref{cstdint}             & Integer types             & \tcode{<cstdint>}     \\ \rowsep
	\cxxref{support.start.term}  & Start and termination     &   \tcode{<cstdlib>}   \\ \rowsep
	\cxxref{support.dynamic}     & Dynamic memory management &   \tcode{<new>}       \\ \rowsep
	\cxxref{support.rtti}        & Type identification       &   \tcode{<typeinfo>}  \\ \rowsep
	\cxxref{support.exception}   & Exception handling        &   \tcode{<exception>} \\ \rowsep
	\cxxref{support.initlist}    & Initializer lists & \tcode{<initializer_list>}    \\ \rowsep
	\added{\ref{support.resumable}} 
  & \added{Resumable functions support} 
  & \added{\tcode{<experimental/resumable>}}    \\ \rowsep
	&                           &   \tcode{<csignal>}   \\
	&                           &   \tcode{<csetjmp>}   \\
	&                           &   \tcode{<cstdalign>} \\
	\cxxref{support.runtime}     & Other runtime support     &   \tcode{<cstdarg>}   \\
	&                           &   \tcode{<cstdbool>}  \\
	&                           &   \tcode{<cstdlib>}   \\
	&                           &   \tcode{<ctime>}     \\
\end{libsumtab}


Add section \ref{support.resumable}

\setcounter{section}{10}
\rSec1[support.resumable]{Resumable functions support library}

\pnum
The header
\tcode{<experimental/resumable]>}
defines several types supporting resumable functions in a \Cpp program.

\synopsis{Header \tcode{<experimental/resumable>} synopsis}

\indextext{\idxhdr{experimental/resumable}}%
\indexlibrary{\idxhdr{experimental/resumable}}%
\begin{codeblock}
namespace std {
namespace experimental {
  template <typename R, typename... ArgTypes>
    class coroutine_traits;
	
  template <typename Promise = void>
    class coroutine_handle;		

  template <> class coroutine_handle<void>;
	
  bool operator == (coroutine_handle<> x, coroutine_handle<> y) noexcept;
  bool operator < (coroutine_handle<> x, coroutine_handle<> y) noexcept;			
  bool operator != (coroutine_handle<> x, coroutine_handle<> y) noexcept;
  bool operator <= (coroutine_handle<> x, coroutine_handle<> y) noexcept;			
  bool operator >= (coroutine_handle<> x, coroutine_handle<> y) noexcept;
  bool operator > (coroutine_handle<> x, coroutine_handle<> y) noexcept;			
}
}
\end{codeblock}

\rSec2[resumable.traits]{Class template \tcode{coroutine_traits}}

\indexlibrary{\idxcode{coroutine_traits}}%
\begin{codeblock}
namespace std {
namespace experimental {
  template <typename R, typename... Ts>
  class coroutine_traits {
  public:
    template <typename... Us>
      static auto get_allocator(Us&&...); // optional
			
    static auto get_return_object_on_allocation_failure() noexcept; // optional
			
    using promise_type = typename R::promise_type;
  };
} // namespace experimental
} // namespace std
\end{codeblock}

\pnum
The class
\tcode{coroutine_traits}
provides bla-bla as specified in~\ref{dcl.fct.def.resumable}.
class for the types of objects thrown as exceptions by
\Cpp standard library components, and certain
expressions, to report errors detected during program execution.

\pnum
The \tcode{coroutine_traits} may be specialized for user-defined types 
to indicate that such types are eligible


\rSec2[resumable.handle]{Class \tcode{coroutine_handle}}

\indexlibrary{\idxcode{coroutine_handle}}%
\begin{codeblock}
namespace std {
namespace experimental {
  template <typename R, typename... Ts>
  class coroutine_traits {
  public:
    template <typename... Us>
    auto get_allocator(Us&&...);
				
    using promise_type = typename R::promise_type;
  };
}
}
\end{codeblock}

\pnum
The class
\tcode{coroutine_traits}
defines the base
class for the types of objects thrown as exceptions by
\Cpp standard library components, and certain
expressions, to report errors detected during program execution.

\rSec2[resumable.promise]{Coroutine promise requirements}

\pnum
A user supplies the definition of the resumable promise to implement 
desired high-level semantics associated with a resumable functions
discovered via specialization of \tcode{coroutine_traits}.
The following tables describe the requirements on
coroutine promise types.

\pnum
The template struct \tcode{allocator_traits}~(\ref{allocator.traits}) supplies
a uniform interface to all allocator types.
Table~\ref{tab:desc.var.def} describes the types manipulated
through allocators. Table~\ref{tab:utilities.allocator.requirements}
describes the requirements on allocator types
and thus on types used to instantiate \tcode{allocator_traits}. A requirement
is optional if the last column of
Table~\ref{tab:utilities.allocator.requirements} specifies a default for a
given expression. Within the standard library \tcode{allocator_traits}
template, an optional requirement that is not supplied by an allocator is
replaced by the specified default expression. A user specialization of
\tcode{allocator_traits} may provide different defaults and may provide
defaults for different requirements than the primary template. Within
Tables~\ref{tab:desc.var.def} and~\ref{tab:utilities.allocator.requirements},
the use of \tcode{move} and \tcode{forward} always refers to \tcode{std::move}
and \tcode{std::forward}, respectively.

\begin{libreqtab2}
	{Descriptive variable definitions}
	{tab:desc.var.def}
	\\ \topline
	\lhdr{Variable} &   \rhdr{Definition}   \\  \capsep
	\endfirsthead
	\continuedcaption\\
	\hline
	\lhdr{Variable} &   \rhdr{Definition}   \\  \capsep
	\endhead
	\tcode{P}    &   a coroutine promise type       \\ \rowsep
	\tcode{p}       &   a value of type \tcode{P} \\ \rowsep
	\tcode{e}       &   a value of \tcode{std::exception_ptr} type   \\ \rowsep
	\tcode{h}       &   a value of \tcode{std::experimental::coroutine_handle<P>} type    \\ \rowsep
	\tcode{T}      &   an arbitrary type    \\ \rowsep
	\tcode{v}      &   a value of type \tcode{T}    \\ \rowsep
\end{libreqtab2}

\indextext{requirements!\idxcode{ResumablePromise}}%
\begin{concepttable}{\tcode{ResumablePromise} requirements}{ResumablePromise}
	{p{1.6in}p{4.15in}}
	\topline
	Expression          &   Note \\ \capsep
	\tcode{P\{\}}     &   Construct an object of type \tcode{P}\\ \rowsep
	\tcode{p.get_return_object()}        &
get_return_object is invoked by the coroutine to construct the
return object prior to reaching the first suspend-resume point.
	\\ \rowsep
	\tcode{p.set_result(v)}     &   
Sets the value associated with the promise. set_result is invoked by
a resumable function when 
a return statement
with an \grammarterm{expression} 
or a \grammarterm{braced-init-list}
is encountered in a resumable function.

If a promise type does not satisfy this requirement, presence of 
a return statement
with an \grammarterm{expression} 
or a \grammarterm{braced-init-list}
statement in the body result in a compile time error.
	\\ \rowsep
	\tcode{p.set_result()}     &   

Sets the value associated with the promise. set_result is invoked by
a resumable function when 
a return statement
without an \grammarterm{expression} 
nor a \grammarterm{braced-init-list}
is encountered in a resumable function.

Program is not well-formed if both p.set_result() and p.set_result(v)
bla bla
	
	\\ \rowsep
	\tcode{p.set_exception(e)}     &   Construct an object of type \tcode{P}\\ \rowsep
	\tcode{p.yield_value(v)}     &   Construct an object of type \tcode{P}\\ \rowsep
	\tcode{p.initial_suspend()}     &   Construct an object of type \tcode{P}\\ \rowsep
	\tcode{p.final_suspend(v)}     &   Construct an object of type \tcode{P}\\ \rowsep
	 \\
\end{concepttable}

\footnotetext{It is intended that \tcode{a.allocate} be an efficient means
	of allocating a single object of type \tcode{T}, even when \tcode{sizeof(T)}
	is small. That is, there is no need for a container to maintain its own
	free list.}
