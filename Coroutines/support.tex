
\setcounter{chapter}{17}
\rSec0[language.support]{Language support library}

\rSec1[support.general]{General}

Add a row to Table~\ref{tab:lang.sup.lib.summary} for \tcode{<experimental/resumable>}


\begin{libsumtab}{Language support library summary}{tab:lang.sup.lib.summary}
	\cxxref{support.types}       & Types                     &   \tcode{<cstddef>}   \\ \rowsep
	&                           &   \tcode{<limits>}    \\
	\cxxref{support.limits}      & Implementation properties &   \tcode{<climits>}   \\
	&                           &   \tcode{<cfloat>}    \\ \rowsep
	\cxxref{cstdint}             & Integer types             & \tcode{<cstdint>}     \\ \rowsep
	\cxxref{support.start.term}  & Start and termination     &   \tcode{<cstdlib>}   \\ \rowsep
	\cxxref{support.dynamic}     & Dynamic memory management &   \tcode{<new>}       \\ \rowsep
	\cxxref{support.rtti}        & Type identification       &   \tcode{<typeinfo>}  \\ \rowsep
	\cxxref{support.exception}   & Exception handling        &   \tcode{<exception>} \\ \rowsep
	\cxxref{support.initlist}    & Initializer lists & \tcode{<initializer_list>}    \\ \rowsep
	\added{\ref{support.resumable}} 
  & \added{Resumable functions support} 
  & \added{\tcode{<experimental/resumable>}}    \\ \rowsep
	&                           &   \tcode{<csignal>}   \\
	&                           &   \tcode{<csetjmp>}   \\
	&                           &   \tcode{<cstdalign>} \\
	\cxxref{support.runtime}     & Other runtime support     &   \tcode{<cstdarg>}   \\
	&                           &   \tcode{<cstdbool>}  \\
	&                           &   \tcode{<cstdlib>}   \\
	&                           &   \tcode{<ctime>}     \\
\end{libsumtab}


Add section \ref{support.resumable}

\setcounter{section}{10}
\rSec1[support.resumable]{Resumable functions support library}

\pnum
The header
\tcode{<experimental/resumable]>}
defines several types supporting resumable functions in a \Cpp program.

\synopsis{Header \tcode{<experimental/resumable>} synopsis}

\indextext{\idxhdr{experimental/resumable}}%
\indexlibrary{\idxhdr{experimental/resumable}}%
\begin{codeblock}
namespace std {
namespace experimental {
  template <typename R, typename... ArgTypes>
    class coroutine_traits;
	
  template <typename Promise = void>
    class coroutine_handle;		

  template <> class coroutine_handle<void>;
	
  bool operator == (coroutine_handle<> x, coroutine_handle<> y) noexcept;
  bool operator < (coroutine_handle<> x, coroutine_handle<> y) noexcept;			
  bool operator != (coroutine_handle<> x, coroutine_handle<> y) noexcept;
  bool operator <= (coroutine_handle<> x, coroutine_handle<> y) noexcept;			
  bool operator >= (coroutine_handle<> x, coroutine_handle<> y) noexcept;
  bool operator > (coroutine_handle<> x, coroutine_handle<> y) noexcept;			
}
}
\end{codeblock}

\rSec2[resumable.traits]{Class template \tcode{coroutine_traits}}

\indexlibrary{\idxcode{coroutine_traits}}%
\begin{codeblock}
namespace std {
namespace experimental {
  template <typename R, typename... Ts>
  class coroutine_traits {
  public:
    template <typename... Us>
      static auto get_allocator(Us&&...); // optional
			
    static auto get_return_object_on_allocation_failure() noexcept; // optional
			
    using promise_type = typename R::promise_type;
  };
} // namespace experimental
} // namespace std
\end{codeblock}

\pnum
The class
\tcode{coroutine_traits}
provides bla-bla as specified in~\ref{dcl.fct.def.resumable}.
class for the types of objects thrown as exceptions by
\Cpp standard library components, and certain
expressions, to report errors detected during program execution.

\pnum
The \tcode{coroutine_traits} may be specialized for user-defined types 
to indicate that such types are eligible


\rSec2[resumable.handle]{Class \tcode{coroutine_handle}}

\indexlibrary{\idxcode{coroutine_handle}}%
\begin{codeblock}
namespace std {
namespace experimental {
  template <typename R, typename... Ts>
  class coroutine_traits {
  public:
    template <typename... Us>
    auto get_allocator(Us&&...);
				
    using promise_type = typename R::promise_type;
  };
}
}
\end{codeblock}

\pnum
The class
\tcode{coroutine_traits}
defines the base
class for the types of objects thrown as exceptions by
\Cpp standard library components, and certain
expressions, to report errors detected during program execution.

\rSec2[resumable.promise]{Coroutine promise requirements}

\pnum
A user supplies the definition of the resumable promise to implement 
desired high-level semantics associated with a resumable functions
discovered via specialization of \tcode{coroutine_traits}.
The following tables describe the requirements on
coroutine promise types.

\pnum
The template struct \tcode{allocator_traits}~(\ref{allocator.traits}) supplies
a uniform interface to all allocator types.
Table~\ref{tab:desc.var.def} describes the types manipulated
through allocators. Table~\ref{tab:utilities.allocator.requirements}
describes the requirements on allocator types
and thus on types used to instantiate \tcode{allocator_traits}. A requirement
is optional if the last column of
Table~\ref{tab:utilities.allocator.requirements} specifies a default for a
given expression. Within the standard library \tcode{allocator_traits}
template, an optional requirement that is not supplied by an allocator is
replaced by the specified default expression. A user specialization of
\tcode{allocator_traits} may provide different defaults and may provide
defaults for different requirements than the primary template. Within
Tables~\ref{tab:desc.var.def} and~\ref{tab:utilities.allocator.requirements},
the use of \tcode{move} and \tcode{forward} always refers to \tcode{std::move}
and \tcode{std::forward}, respectively.

\begin{libreqtab2}
	{Descriptive variable definitions}
	{tab:desc.var.def}
	\\ \topline
	\lhdr{Variable} &   \rhdr{Definition}   \\  \capsep
	\endfirsthead
	\continuedcaption\\
	\hline
	\lhdr{Variable} &   \rhdr{Definition}   \\  \capsep
	\endhead
	\tcode{P}    &   a coroutine promise type       \\ \rowsep
	\tcode{r}       &   a value of type \tcode{P} \\ \rowsep
	\tcode{E}       &   a value of \tcode{std::exception_ptr} type   \\ \rowsep
	\tcode{h}       &   a value of \tcode{std::experimental::coroutine_handle<P>} type    \\ \rowsep
	\tcode{T}      &   an arbitrary type    \\ \rowsep
	\tcode{v}      &   a value of type \tcode{T}    \\ \rowsep
\end{libreqtab2}

\begin{libreqtab4d}
	{Coroutine promise requirements}
	{tab:support.coroutine.promise.requirements}
	\\ \topline
	\lhdr{Expression}   &   \chdr{Return type}  &   \chdr{Assertion/note} & \rhdr{Default}       \\
	&                       &   \chdr{pre-/post-condition}  &   \\ \capsep
	\endfirsthead
	\continuedcaption\\
	\hline
	\lhdr{Expression}   &   \chdr{Return type}  &   \chdr{Assertion/note} & \rhdr{Default}       \\
	&                       &   \chdr{pre-/post-condition}  &   \\ \capsep
	\endhead
	\tcode{X::pointer}          &          &   & \tcode{T*} \\ \rowsep
	
	\tcode{X::const_pointer}    &
	&
	\tcode{X::pointer} is convertible to \tcode{X::const_pointer}   &
	\tcode{pointer_traits<X::\brk{}pointer>::\brk{}rebind<const T>}             \\ \rowsep
	
	\tcode{X::void_pointer}\br\tcode{Y::void_pointer} &
	&
	\tcode{X::pointer} is convertible to \tcode{X::void_pointer}.
	\tcode{X::void_pointer} and \tcode{Y::void_pointer} are the same type.  &
	\tcode{pointer_traits<X::\brk{}pointer>::\brk{}rebind<void>} \\ \rowsep
	
	\tcode{X::const_void_pointer}\br\tcode{Y::const_void_pointer} &
	&
	\tcode{X::pointer}, \tcode{X::const_pointer}, and \tcode{X::void_pointer} are convertible to \tcode{X::const_void_pointer}.
	\tcode{X::const_void_pointer} and \tcode{Y::const_void_pointer} are the same type.  &
	\tcode{pointer_traits<X::\brk{}pointer>::\brk{}rebind<const void>} \\ \rowsep
	
	\tcode{X::value_type}       &
	Identical to \tcode{T}    &   & \\ \rowsep
	
	\tcode{X::size_type}        &
	unsigned integer type     &
	a type that can represent the size of the largest object in the allocation model. &
	\tcode{make_unsigned_t<X::\brk{}difference_type>} \\ \rowsep
	
	\tcode{X::difference_type}  &
	signed integer type       &
	a type that can represent the difference between any two pointers
	in the allocation model.&
	\tcode{pointer_traits<X::\brk{}pointer>::\brk{}difference_type} \\ \rowsep
	
	\tcode{typename X::template rebind<U>::other}   &
	\tcode{Y}                 &
	For all \tcode{U} (including \tcode{T}), \tcode{Y::template rebind<T>::other}
	is \tcode{X}.           &
	See Note A, below.        \\ \rowsep
	
	\tcode{*p}                  &
	\tcode{T\&}               && \\ \rowsep
	
	\tcode{*q}                  &
	\tcode{const T\&}         &
	\tcode{*q} refers to the same object as \tcode{*p}& \\ \rowsep
	
	\tcode{p->m}                &
	type of \tcode{T::m}      &
	\textit{pre:} \tcode{(*p).m} is well-defined. equivalent to \tcode{(*p).m}  & \\ \rowsep
	
	\tcode{q->m}                &
	type of \tcode{T::m}      &
	\textit{pre:} \tcode{(*q).m} is well-defined. equivalent to \tcode{(*q).m}  & \\ \rowsep
	
	\tcode{static_-} \tcode{cast<X::pointer>(w)}  &
	\tcode{X::pointer}                &
	\tcode{static_cast<X::pointer>(w)} \tcode{== p} & \\ \rowsep
	
	\tcode{static_cast<X} \tcode{::const_pointer>(z)}  &
	\tcode{X::const_pointer}                &
	\tcode{static_cast<X} \tcode{::const_pointer>(z)} \tcode{== q} & \\ \rowsep
	
	\tcode{a.allocate(n)}   &   \tcode{X::pointer}  &
	Memory is allocated for \tcode{n} objects of type \tcode{T} but objects
	are not constructed. \tcode{allocate} may raise an appropriate exception.\footnotemark
	\enternote
	If \tcode{n == 0}, the return value is unspecified.
	\exitnote              &  \\ \rowsep
	
	\tcode{a.allocate(n, u)}    &
	\tcode{X::pointer}        &
	Same as \tcode{a.allocate(n)}. The use of \tcode{u} is unspecified, but
	it is intended as an aid to locality. &
	\tcode{a.allocate(n)}     \\ \rowsep
	
	\tcode{a.deallocate(p,n)}   &
	(not used)                &
	All \tcode{n T} objects in the area pointed to by \tcode{p} shall be
	destroyed prior to this call. \tcode{n} shall match the value passed to
	\tcode{allocate} to obtain this memory. Does not throw exceptions.
	\enternote \tcode{p} shall not be singular.\exitnote   &  \\ \rowsep
	
	\tcode{a.max_size()}        &
	\tcode{X::size_type}      &
	the largest value that can meaningfully be passed to \tcode{X::allocate()}  &
	\tcode{numeric_limits<size_type>::max()}  \\ \rowsep
	
	\tcode{a1 == a2}            &
	\tcode{bool}              &
	returns \tcode{true} only if storage allocated from each can
	be deallocated via the other. \tcode{operator==} shall be reflexive, symmetric,
	and transitive, and shall not exit via an exception. &  \\ \rowsep
	
	\tcode{a1 != a2}            &
	\tcode{bool}              &
	same as \tcode{!(a1 == a2)}     & \\ \rowsep
	
	\tcode{a == b}              &
	\tcode{bool}              &
	same as \tcode{a ==} \tcode{Y::rebind<T>::other(b)} & \\ \rowsep
	
	\tcode{a != b}              &
	\tcode{bool}              &
	same as \tcode{!(a == b)} & \\ \rowsep
	
	\tcode{X a1(a)};            \br
	\tcode{X a1 = a;}           &
	&
	Shall not exit via an exception.\br
	post: \tcode{a1 == a}     & \\ \rowsep
	
	\tcode{X a(b);}             &
	&
	Shall not exit via an exception.\br
	post: \tcode{Y(a) == b}, \tcode{a == X(b)} &  \\ \rowsep
	
	\tcode{X a1(move(a));}      \br
	\tcode{X a1 = move(a);}     &
	&
	Shall not exit via an exception.\br
	post: \tcode{a1} equals the prior value of \tcode{a}. & \\ \rowsep
	
	\tcode{X a(move(b));}       &
	&
	Shall not exit via an exception.\br
	post: \tcode{a} equals the prior value of \tcode{X(b)}. & \\ \rowsep
	
	\tcode{a.construct(c, args)}&
	(not used)                &
	Effect: Constructs an object of type \tcode{C} at
	\tcode{c}               &
	\tcode{::new ((void*)c) C(forward<\brk{}Args>\brk(args)...)}  \\ \rowsep
	
	\tcode{a.destroy(c)}        &
	(not used)                &
	Effect: Destroys the object at \tcode{c}  &
	\tcode{c->\~{}C()}           \\  \rowsep
	
	\tcode{a.select_on_container_copy_construction()} &
	\tcode{X}                 &
	Typically returns either \tcode{a} or \tcode{X()} &
	\tcode{return a;}         \\ \rowsep
	
	\tcode{X::propagate_on_container_copy_assignment} &
	Identical to or derived from \tcode{true_type} or \tcode{false_type}  &
	\tcode{true_type} only if an allocator of type \tcode{X} should be copied
	when the client container is copy-assigned.   &
	\tcode{false_type}        \\ \rowsep
	
	\tcode{X::propagate_on_container_move_assignment} &
	Identical to or derived from \tcode{true_type} or \tcode{false_type}  &
	\tcode{true_type} only if an allocator of type \tcode{X} should be moved
	when the client container is move-assigned.   &
	\tcode{false_type}        \\ \rowsep
	
	\tcode{X::propagate_on_-} \tcode{container_swap} &
	Identical to or derived from \tcode{true_type} or \tcode{false_type}  &
	\tcode{true_type} only if an allocator of type \tcode{X} should be swapped
	when the client container is swapped.   &
	\tcode{false_type}        \\
	
\end{libreqtab4d}

\footnotetext{It is intended that \tcode{a.allocate} be an efficient means
	of allocating a single object of type \tcode{T}, even when \tcode{sizeof(T)}
	is small. That is, there is no need for a container to maintain its own
	free list.}
