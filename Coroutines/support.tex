
\setcounter{chapter}{17}
\rSec0[language.support]{Language support library}

\rSec1[support.general]{General}

Add a row to Table~\ref{tab:lang.sup.lib.summary} for coroutine support header \tcode{<coroutine>}.


\begin{libsumtab}{Language support library summary}{tab:lang.sup.lib.summary}
	\cxxref{support.types}       & Types                     &   \tcode{<cstddef>}   \\ \rowsep
	&                           &   \tcode{<limits>}    \\
	\cxxref{support.limits}      & Implementation properties &   \tcode{<climits>}   \\
	&                           &   \tcode{<cfloat>}    \\ \rowsep
	\cxxref{cstdint}             & Integer types             & \tcode{<cstdint>}     \\ \rowsep
	\cxxref{support.start.term}  & Start and termination     &   \tcode{<cstdlib>}   \\ \rowsep
	\cxxref{support.dynamic}     & Dynamic memory management &   \tcode{<new>}       \\ \rowsep
	\cxxref{support.rtti}        & Type identification       &   \tcode{<typeinfo>}  \\ \rowsep
	\cxxref{support.exception}   & Exception handling        &   \tcode{<exception>} \\ \rowsep
	\cxxref{support.initlist}    & Initializer lists & \tcode{<initializer_list>}    \\ \rowsep
	\added{\ref{support.coroutine}} 
  & \added{Coroutines support} 
  & \added{\tcode{<coroutine>}}    \\ \rowsep
	&                           &   \tcode{<csignal>}   \\
	&                           &   \tcode{<csetjmp>}   \\
	&                           &   \tcode{<cstdalign>} \\
	\cxxref{support.runtime}     & Other runtime support     &   \tcode{<cstdarg>}   \\
	&                           &   \tcode{<cstdbool>}  \\
	&                           &   \tcode{<cstdlib>}   \\
	&                           &   \tcode{<ctime>}     \\
\end{libsumtab}


\setcounter{section}{9}
\rSec1[support.runtime]{Other runtime support}

Add underlined text to paragraph 4.

\begin{quote}
\setcounter{Paras}{3}
\pnum
The function signature
\indexlibrary{\idxcode{longjmp}}%
\tcode{longjmp(jmp_buf jbuf, int val)}
has more restricted behavior in this International Standard.
A \tcode{setjmp}/\tcode{longjmp} call pair has undefined
behavior if replacing the \tcode{setjmp} and \tcode{longjmp}
by \tcode{catch} and \tcode{throw} would invoke any non-trivial destructors for any automatic
objects.
%
\added{A call to \tcode{setjmp} or \tcode{longjmp} has undefined
behavior if invoked in a coroutine.}

\xref ISO C~7.10.4, 7.8, 7.6, 7.12.
\end{quote}

\setcounter{section}{10}
\rSec1[support.coroutine]{Coroutines support library}

Add this section to clause \ref{language.support}.

\begin{quote}

\pnum
The header
\tcode{<coroutine>}
defines several types providing compile and run-time support for coroutines in a \Cpp program.

\synopsis{Header \tcode{<coroutine>} synopsis}

\indextext{\idxhdr{coroutine}}%
\indexlibrary{\idxhdr{coroutine}}%
\begin{codeblock}
namespace std {
  inline namespace coroutines_v1 {
    // \ref{coroutine.traits} coroutine traits
    template <typename R, typename... ArgTypes>
      class coroutine_traits;
  	
    // \ref{coroutine.handle} coroutine handle
    template <typename Promise = void>
      class coroutine_handle;		
  
    // \ref{coroutine.handle.compare} comparison operators:	
    bool operator==(coroutine_handle<> x, coroutine_handle<> y) noexcept;
    bool operator<(coroutine_handle<> x, coroutine_handle<> y) noexcept;			
    bool operator!=(coroutine_handle<> x, coroutine_handle<> y) noexcept;
    bool operator<=(coroutine_handle<> x, coroutine_handle<> y) noexcept;			
    bool operator>=(coroutine_handle<> x, coroutine_handle<> y) noexcept;
    bool operator>(coroutine_handle<> x, coroutine_handle<> y) noexcept;
    
    // \ref{coroutine.trivial.awaitables} trivial awaitables
    struct suspend_never;
    struct suspend_always;
    
  } // namespace coroutines_v1

  // \ref{coroutine.handle.hash} hash support:
  template <class T> struct hash;
  template <class P> struct hash<coroutine_handle<P>>;
} // namespace std
\end{codeblock}

\rSec2[coroutine.traits]{coroutine traits}
\pnum
This subclause defines requirements on classes representing
\term{coroutine traits},
and defines the class template
\tcode{coroutine_traits}
that satisfies those requirements.

%\pnum
%Coroutines need a set of related types and functions
%to complete the definition of their semantics.
%These types and functions are provided as a set of member types or typedefs
%and functions in the instantiation of struct template
%\tcode{coroutine_traits}. This subclause defines the semantics of these
%members.

\pnum
The \tcode{coroutine_traits} may be specialized by the user 
to customize the semantics of coroutines.

%\rSec3[coroutine.traits.requirements]{Coroutine traits requirements}
%\pnum
%In Table~\ref{tab:coroutine.traits.requirements}, X denotes 
%a trait class instantiated as described in \ref{dcl.fct.def.coroutine}.
%
%;
%If a coroutine is a member function, then $a_1$ denotes the implicit \tcode{this} parameter, $a_2$, ... $a_n$ refer to explicit parameters of the coroutine, otherwise, $a_1$, $a_2$, ... $a_n$ denote the parameters of the coroutine. 
%
%\begin{concepttable}{Coroutine traits requirements}{tab:coroutine.traits.requirements}
%  {p{1.6in}p{4.15in}}
%  \topline
%  Expression          &   Behavior \\ \capsep
%  \tcode{X::promise_type}     &
%  \tcode{X::promise_type} must be a type satisfying coroutine promise requirements (\ref{coroutine.promise}) 
%\\ 
%\end{concepttable}

\rSec3[coroutine.traits.primary]{Struct template \tcode{coroutine_traits}}
\pnum The header \tcode{<coroutine>} shall define
the class template \tcode{coroutine_traits} as follows:

%\pnum The requirements for the members are given in clause \ref{coroutine.traits.requirements}.
\indexlibrary{\idxcode{coroutine_traits}}%
\begin{codeblock}
namespace std {
inline namespace coroutines_v1 {
  template <typename R, typename... Args>
  struct coroutine_traits {
    using promise_type = typename R::promise_type;
  };
} // namespace coroutines_v1
} // namespace std
\end{codeblock}

\rSec2[coroutine.handle]{Struct template \tcode{coroutine_handle}}

\indexlibrary{\idxcode{coroutine_handle}}%
\begin{codeblock}
namespace std {
  inline namespace coroutines_v1 {
    template <>
    struct coroutine_handle<void>
    {
      // \ref{coroutine.handle.con} construct/reset
      constexpr coroutine_handle() noexcept;		
      constexpr coroutine_handle(nullptr_t) noexcept;
      coroutine_handle& operator=(nullptr_t) noexcept;
      
      // \ref{coroutine.handle.export} export/import
      void* address() const noexcept;
      static coroutine_handle from_address(void* addr) noexcept;		
      
      // \ref{coroutine.handle.capacity} capacity
      explicit operator bool() const noexcept;
      
      // \ref{coroutine.handle.resumption} resumption
      void operator()() const;
      void resume() const;	
      void destroy() const;
      
      // \ref{coroutine.handle.completion} completion check
      bool done() const noexcept; 
    };
    
    template <typename Promise>
    struct coroutine_handle : coroutine_handle<>
    {
      // \ref{coroutine.handle.con} construct/reset
      using coroutine_handle<>::coroutine_handle;
      static coroutine_handle from_promise(Promise&) noexcept;		
      coroutine_handle& operator=(nullptr_t) noexcept;
      
      // \ref{coroutine.handle.prom} promise access
      Promise& promise() const noexcept;		
    };
  } // namespace coroutines_v1
} // namespace std
\end{codeblock}

\pnum
Let \textit{P} be a promise type of the coroutine (\ref{dcl.fct.def.coroutine}). An object of the type \tcode{coroutine_handle<\textit{P}>} is called a \term{coroutine handle}
and can be used to refer to a suspended or executing coroutine.
A default constructed \tcode{coroutine_handle} object does not refer to any coroutine.

%Such a function is called a \textit{target} of a coroutine handle.
%A default constructed \tcode{coroutine_handle} object has no target.


\rSec3[coroutine.handle.con]{\tcode{coroutine_handle} construct/reset}
\begin{itemdecl}
  constexpr coroutine_handle() noexcept;		
  constexpr coroutine_handle(nullptr_t) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\postconditions \tcode{address() == nullptr}.
\end{itemdescr}

\begin{itemdecl}
  static coroutine_handle::from_promise(Promise& p) noexcept;	
\end{itemdecl}
\begin{itemdescr}
  \pnum
  \precondition \tcode{p} is a reference to a promise object of a coroutine.
  
	\pnum
  \postconditions \tcode{address() != nullptr} and \tcode{addressof(promise()) == addressof(p)}.
\end{itemdescr}

\begin{itemdecl}
  coroutine_handle& operator=(nullptr_t) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum\postconditions \tcode{address() == nullptr}.
  
  \pnum\returns \tcode{*this}.
\end{itemdescr}

\rSec3[coroutine.handle.export]{\tcode{coroutine_handle} export/import}
\begin{itemdecl}
  static coroutine_handle from_address(void* addr) noexcept;		
  void* address() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \postconditions \tcode{coroutine_handle<>::from_address(address()) == *this}.
\end{itemdescr}

\rSec3[coroutine.handle.capacity]{\tcode{coroutine_handle} capacity}
\begin{itemdecl}
  explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns \tcode{true} if \tcode{address() != nullptr}, otherwise \tcode{false}.
\end{itemdescr}

\rSec3[coroutine.handle.resumption]{\tcode{coroutine_handle} resumption}
\begin{itemdecl}
  void operator()() const;
  void resume() const;	
\end{itemdecl}
\begin{itemdescr}
  \pnum
  \precondition \tcode{*this} refers to a suspended coroutine.
  
  \pnum
  \effects resumes the execution of the coroutine. If the coroutine was suspended
  at the final suspend point, behavior is undefined.
\end{itemdescr}

\begin{itemdecl}
  void destroy() const;
\end{itemdecl}
\begin{itemdescr}
  \pnum
  \precondition \tcode{*this} refers to a suspended coroutine.
  
  \pnum
  \effects destroys the coroutine (\ref{dcl.fct.def.coroutine}).
\end{itemdescr}

\rSec3[coroutine.handle.completion]{\tcode{coroutine_handle} completion check}
\begin{itemdecl}
  bool done() const noexcept; 
\end{itemdecl}
\begin{itemdescr}
  \pnum
  \precondition \tcode{*this} refers to a suspended coroutine.
  
  \pnum
  \returns \tcode{true} if the coroutine is suspended
  at final suspend point, otherwise \tcode{false}.
\end{itemdescr}

\rSec3[coroutine.handle.prom]{\tcode{coroutine_handle} promise access}
\begin{itemdecl}
  Promise& promise() noexcept;		
  Promise const& promise() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \precondition \tcode{*this} refers to a coroutine.
  
  \pnum
  \returns a reference to a promise of the coroutine.
\end{itemdescr}

\rSec3[coroutine.handle.compare]{Comparison operators}

\begin{itemdecl}
  bool operator==(coroutine_handle<> x, coroutine_handle<> y) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns \tcode{x.address() == y.address()}.
\end{itemdescr}

\begin{itemdecl}
  bool operator<(coroutine_handle<> x, coroutine_handle<> y) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns \tcode{less<void*>()(x.address(), y.address())}.
\end{itemdescr}

\begin{itemdecl}
  bool operator!=(coroutine_handle<> x, coroutine_handle<> y) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns \tcode{!(x == y)}.
\end{itemdescr}

\begin{itemdecl}
  bool operator>(coroutine_handle<> x, coroutine_handle<> y) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns \tcode{(y < x)}.
\end{itemdescr}

\begin{itemdecl}
  bool operator<=(coroutine_handle<> x, coroutine_handle<> y) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns \tcode{!(x > y)}.
\end{itemdescr}

\begin{itemdecl}
  bool operator>=(coroutine_handle<> x, coroutine_handle<> y) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns \tcode{!(x < y)}.
\end{itemdescr}

\rSec3[coroutine.handle.hash]{Hash support}

\begin{itemdecl}
  template <class P> struct hash<coroutine_handle<P>>;
\end{itemdecl}

\begin{itemdescr}
  \pnum
The template specializations shall meet the requirements of class template hash (\cxxref{unord.hash}).
\end{itemdescr}

\rSec2[coroutine.trivial.awaitables]{trivial awaitables}
The header \tcode{<coroutine>} shall define \tcode{suspend_never} and \tcode{suspend_always} as follows.
\begin{codeblock}
  struct suspend_never {
    bool await_ready() { return true; }
    void await_suspend(coroutine_handle<>) {}
    void await_resume() {}
  };
  struct suspend_always {
    bool await_ready() { return false; }
    void await_suspend(coroutine_handle<>) {}
    void await_resume() {}
  };
\end{codeblock}
\end{quote}

%\rSec2[coroutine.promise]{Coroutine promise requirements}
%
%\pnum
%A user supplies the definition of the coroutine promise to implement 
%desired high-level semantics associated with a coroutines
%discovered via instantiation of class template \tcode{coroutine_traits}.
%The following tables describe the requirements on
%coroutine promise types.
%
%%\pnum
%%The template struct \tcode{allocator_traits}~(\ref{allocator.traits}) supplies
%%a uniform interface to all allocator types.
%%Table~\ref{tab:desc.var.def} describes the types manipulated
%%through allocators. Table~\ref{tab:utilities.allocator.requirements}
%%describes the requirements on allocator types
%%and thus on types used to instantiate \tcode{allocator_traits}. A requirement
%%is optional if the last column of
%Table~\ref{tab:utilities.allocator.requirements} specifies a default for a
%%given expression. Within the standard library \tcode{allocator_traits}
%%template, an optional requirement that is not supplied by an allocator is
%%replaced by the specified default expression. A user specialization of
%%\tcode{allocator_traits} may provide different defaults and may provide
%%defaults for different requirements than the primary template. Within
%%Tables~\ref{tab:desc.var.def} and~\ref{tab:utilities.allocator.requirements},
%%the use of \tcode{move} and \tcode{forward} always refers to \tcode{std::move}
%%and \tcode{std::forward}, respectively.
%
%\begin{libreqtab2}
%	{Descriptive variable definitions}
%	{tab:desc.var.def}
%	\\ \topline
%	\lhdr{Variable} &   \rhdr{Definition}   \\  \capsep
%	\endfirsthead
%	\continuedcaption\\
%	\hline
%	\lhdr{Variable} &   \rhdr{Definition}   \\  \capsep
%	\endhead
%	\tcode{Promise}    &   a coroutine promise type       \\ \rowsep
%	\tcode{p}       &   a value of type \tcode{Promise} \\ \rowsep
%	\tcode{e}       &   a value of \tcode{exception_ptr} type   \\ \rowsep
%	\tcode{h}       &   a value of \tcode{coroutine_handle<P>} type    \\ \rowsep
%	\tcode{v}      &   an \grammarterm{expression} or \grammarterm{braced-init-list}   \\ \rowsep
%\end{libreqtab2}
%
%\indextext{requirements!\idxcode{CoroutinePromise}}%
%\begin{concepttable}{\tcode{CoroutinePromise} requirements}{CoroutinePromise}
%	{p{1.6in}p{4.15in}}
%	\topline
%	Expression          &   Note \\ \capsep
%	\tcode{Promise\{\}}     &   Construct an object of type \tcode{Promise}\\ \rowsep
%	\tcode{p.get_return_object()}        &
%The \tcode{get_return_object} is invoked by the coroutine to construct the
%return object prior to reaching the first suspend-resume point,
%a \tcode{return} statement, or flowing off the end of the function.
%	\\ \rowsep
%	\tcode{Promise::get_return_object_on_allocation_failure()}        &
%  \textit{(Optional)} The \tcode{get_return_object_on_allocation_failure} is invoked by the coroutine to construct the
%  return object if allocation of the coroutine state failed.
%  \\ \rowsep
%	\tcode{p.return_value(v)}     &  
%%If present, an enclosing coroutine supports an
%%eventual value of a type that \tcode{v} can be converted to. 
%
%\textit{(Optional)} Invoked by
%a coroutine when 
%a \tcode{return} statement with an operand
%is encountered in a coroutine as described in (\ref{stmt.return.coroutine}).
%%If a promise type does not satisfy this requirement, the presence of 
%%a \tcode{coreturn} statement
%%with an \grammarterm{expression} 
%%or a \grammarterm{braced-init-list}
%%statement in the body results in a compile time error.
%	\\ \rowsep
%	\tcode{p.return_void()}     &   
%%If present, an enclosing coroutine supports an eventual value of type \tcode{void}. 
%\textit{(Optional)} Invoked when 
%a \tcode{return} statement is encountered as described in (\ref{stmt.return.coroutine}).
%	\\ \rowsep
%	\tcode{p.set_exception(e)} & 
%\textit{(Optional)} If present, the \tcode{set_exception} is invoked by a coroutine when an
%unhandled exception occurs within a \grammarterm{function-body} of the coroutine.
%If the promise does not provide \tcode{set_exception}, an unhandled exception
%will propagate from the coroutine normally.
%\\ \rowsep
%	\tcode{p.yield_value(v)}     &
%\textit{(Optional)} The \tcode{yield_value} is invoked
%  when \tcode{co_yield} statement is
%  encountered in the coroutine. If
%  promise does not define \tcode{yield_value}, \tcode{co_yield}
%  statement shall not appear in the coroutine body.
%	\\ \rowsep
%	\tcode{p.initial_suspend()}     &
%A coroutine invokes \tcode{p.initial_suspend()} to obtain awaitable for \textit{initial suspend point} (\ref{dcl.fct.def.coroutine}).
%	   \\ \rowsep
%	\tcode{p.final_suspend()}     &  
%A coroutine invokes \tcode{p.final_suspend()} to obtain awaitable for \textit{final suspend point} (\ref{dcl.fct.def.coroutine}).
%\\ 
%\end{concepttable}
%
%\pagebreak
%\pnum
%\enterexample
%This example illustrates full implementation
%of a promise type for a simple generator.
%\begin{codeblock}
%  #include <iostream>
%  #include <coroutine>
%  
%  struct generator {
%    struct promise_type {
%      int current_value;
%      auto get_return_object() { return generator{*this}; }
%      auto initial_suspend() { return std::suspend_always{}; }
%      auto final_suspend() { return std::suspend_always{}; }
%      auto yield_value(int value) { 
%        current_value = value; 
%        return std::suspend_always{};
%      }
%    };
%    
%    bool move_next() {
%      coro.resume();
%      return !coro.done();
%    }
%    
%    int current_value() { return coro.promise().current_value; }
%    
%    ~generator() { coro.destroy(); }
%  private:
%    using handle = std::coroutine_handle<promise_type>;
%    explicit generator(promise_type& myPromise): coro(handle::from_promise(myPromise)) {}
%    handle coro;
%  };
%  
%  generator f() {
%    co_yield 1;
%    co_yield 2;
%  } 
%  
%  int main() {
%    auto g = f();
%    while (g.move_next()) std::cout << g.current_value() << std::endl;
%  }
%  
%\end{codeblock}
%\exitexample
%
%\end{quote}
